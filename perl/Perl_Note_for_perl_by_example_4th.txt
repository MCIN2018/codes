
###############
################

5章： what’s in a name

##################
##################

Single quotes are the "democratic" quotes. All characters enclosed within them are treated equally; in other words, there are no special characters. But the double quotes discriminate. They treat some of the characters in the string as special characters. The special characters include the $ sign, the @ symbol, and escape sequences such as \t and \n.
单引号里的一切都按原样打印出来，双引号会解释特殊字符，比如$ \t \n等。 所以要打印出特殊字符要放在单引号里。

If a string is enclosed in single quotes, it is printed literally (what you see is what you get).

　所见即所得。

*******
Curly Braces
可以替换变量。
1   $var="net";
2   print "${var}work\n";

(Output)
2   network

********
The $_ Scalar Variable: hold the default search pattern or the current line.:存贮当前值 
:::::::::: 
>perl -e ' $_="Christine"; print "$_\n";'
(Output:)
Christine


***********Arrays:**********
Perl doesn't care whether the elements of an array are of the same data type. They can be a mix of numbers and strings 数组类型是什么都可以，不要求所有元素一致。
@pals = ( "John", "Sam", "Nicky", "Jake" )；

The special scalar variable $#arrayname returns the number of the last subscript in the array. Since the array subscripts start at zero, this value is one less than the array size.  $#返回最后一个值的位置，可是因为数组从0开始计数，这个值比数组个数少1

***The Range Operator and Array Assignment ： 范围运算符，注意.. 前后均有空格
@digits=(0 .. 10);
 @letters=( 'A' .. 'Z' );
 @alpha=( 'A' .. 'Z', 'a' .. 'z' );
@n=( -5 .. 20 );


************
5.2.3. Hashes
**********
%days=("Mon" => "Monday",
           "Tue" => "Tuesday",
           "Wed" => undef,
          );



*******************
5.3. Reading from STDIN

***********************
The three filehandles STDIN, STDOUT, and STDERR

***chop and chomp ****

chop砍掉最后一个字符，不论是什么。chmop砍掉最后一个字符，只有当它是换行的时候。
1   print "Hello there, and what is your name? ";
2   $name = <STDIN>;
3   print "$name is a very high class name.\n";
4   chop($name);   # Removes the last character no matter what it is.
5   print "$name is a very high class name.\n\n";
6   chop($name);
7   print "$name has been chopped a little too much.\n";
8   print "What is your age?  ";
9   chomp($age=<STDIN>); # Removes the last character if
                         # it is the newline.
10  chomp($age);         # The last character is not removed
                         # unless a newline.
11  print "For $age, you look so young!\n";

(Output)
1   Hello there, and what is your name? Joe Smith
3   Joe Smith
    is a very high class name.
5   Joe Smith is a very high class name.

7   Joe Smit has been chopped a little too much.

8   What is your age？ 25
11  For 25, you look so young!

****************
read function

number_of_bytes = read(FILEHANDLE,buffer,how_many_bytes);
If reading from standard input, the filehandle is STDIN.  如果是从标准输入读入，那么文件句柄是STDIN

$number=read(STDIN, $favorite, 10);
The 10 characters read in are printed. The rest of the characters were discarded. 只有10个存进favorite 里的，后面的都被忽略了。


************
getc function

$restofit=<>;  # <> store　the input buff content.  <>里存缓存中的内容。 是什么就存什么。

print "Answer Y or N \n";
$answer=getc;
print "$answer.\n";   #通过这样的方式获得


**************
Assigning Input to an Array： 　从终端为数组赋值

@all = <STDIN>;
print "@all";
print "The number of elements in the array are: ",
           $#all + 1, ".\n";
print "The first element of the array is: $all[0]";


**************
5.4. Array Functions

**************
chop and chomp 和之前叙述类似， 不过，chop 返回的是它最后砍掉的变量，chomp返回的是它砍掉的变量的个数。

The chop function chops off the last character of a string and returns the chopped character, usually for removing the newline after input is assigned to a scalar variable. If a list is chopped, chop will remove the last letter of each string in the list.
The chomp function removes the last character of each element in a list if it ends with a newline and returns the number of newlines it removed.

一个栗子： 注意它们对应的输出。 看如何chop不论最后一个字符是什么，都无情删掉，最后保存最后一个删掉的字符，chomp只删掉换行，保存的是删掉的数量，而不是内容：
 @line=("red\n", "green", "orange");
 $chop_today=chop(@line);   # Chops the last character off each
1:print "chop_today is $chop_today.\n";
# string in the list
2: print "@line";
print "\n";
@line=( "red\n", "green\n", "orange");
$chomp_today=chomp(@line);  # Chomps the newline off each string in the list
3: print "@line";
print "\n";
4: print "chomp_today is $chomp_today.\n";

（output)
1: chop_today is e.
2: red gree orang
3: red green orange
4: chomp_today is 2.

********
5.4.2. The exists Function

The exists function returns true if an array index (or hash key) has been defined, and false if it has not. 数组索引存在也返回真，否则假。

@names=('Chris', 'Lynn' ,'Joanna');
print " Hello $names[0]\n", if exists $names[0];
print " Out of range\n", if not exists $names[4];
$exist_test_ture= exists $names[0];
$exist_test_faule= not exists $names[4];
print "exist_test_ture result is $exist_test_ture; exist_test_faule result is $exist_test_faule.\n";

(Output)
 Hello Chris
 Out of range
exist_test_ture result is 1; exist_test_faule result is 1. # 如果是 $exist_test_faule=  exists $names[4]; 返回值是空


********
5.4.3. The delete Function

The delete function allows you to remove a value from an element of an array but not the element itself. The value deleted is simply undefined. 删除掉指定的数组元素的值。该值成为未定义。数组大小不变。
1 @colors=("red","green","blue","yellow");
2  print "@colors\n";
3 delete $colors[1];  # green is removed
4 print "@colors\n";
5 print $colors[1],"\n";
6 $size=@colors;      # value is now undefined
7 print "The size of the array is $size.\n";

(Output)
2 red green blue yellow
4 red  blue yellow
7 The size of the array is 4.


**********
5.4.4. The grep Function
grep(EXPR,LIST)返回值是一个找到的结果的数组。如果是As a scalar value, the return value is the number of times the expression was true (i.e., the number of times the pattern was found).

@grep_test=("English","French","German","Chinese","Ten");
@grep_test_result=grep (/en/i,@grep_test);
$grep_test_result=grep (/en/i,@grep_test);
print "\@grep_test_result is @grep_test_result.\n";
print "\$grep_test_result is $grep_test_result.\n";
(Output)
@grep_test_result is English French Ten.
$grep_test_result is 3.


***********
5.4.5. The join Function
join(DELIMITER, LIST)  The join function joins the elements of an array into a single string and separates each element of the array with a given delimiter. 把一系列的数组元素连成一个串，用给定的分隔符分割。是split的反操作。

$you="You";
$are="are";
$fool="a fool";
$youareafool=join(" ",$you,$are,$fool);
@youareafool=join(" ",$you,$are,$fool);
@youareafool_1=join("-",$you,$are,$fool);
@youareafool_2=join("\n",$you,$are,$fool);
print "\$youareafool is $youareafool. \n";
print "\@youareafool is @youareafool. \n";
print "The second element of \@youareafool is $youareafool[1].\n ";
print "\@youareafool_1 is @youareafool_1. \n";
print "The first element of \@youareafool_1 is $youareafool_1[0].\n ";
print "\@youareafool_2 is @youareafool_2. \n";
print "The first element of \@youareafool_2 is $youareafool_2[0].\n ";
print "The Second element of \@youareafool_2 is $youareafool_2[1].\n ";

print " The size of \@youareafool_1 is ",$#youareafool_1 +1 ,"\n";
print " The size of \@youareafool_2 is ",$#youareafool_2 +1 ,"\n";

(Output)
$youareafool is You are a fool. 
@youareafool is You are a fool. 
The second element of @youareafool is .
 @youareafool_1 is You-are-a fool. 
The first element of @youareafool_1 is You-are-a fool.
 @youareafool_2 is You
are
a fool. 
The first element of @youareafool_2 is You
are
a fool.
 The Second element of @youareafool_2 is .

The size of @youareafool_1 is 1
 The size of @youareafool_2 is 1
#非常有意思的情况。 说明，join 的结果就是一个串。你可以把它存成一个数组，但结果是，这个数组只有一个元素，就是它的第一个元素.


数组的个数两种计算方法

@array_123=("Spring","Summer","Autumn","winter");
$count_123=@array_123;
print " the number of elements in the array is : $count_123 \n";
print " the number of elements in the array is :",  $#count_123 +1," \n";

***************
5.4.6. The map Function

就是把指定的列表数据，用指定的表达展现出来

map EXPR, LIST;
map {BLOCK} LIST;

一个栗子
print "\n *** map {BLOCK} list ****\n";
open(FH,"datebook.master") or die;
@array_132=<FH>;
print "The original array is: @array_132\n";
#有这两种实现方式
@array_after_map= map {split(":")} @array_132;
@array_20190325=map split(":"),@array_132;
# 此两种方法输出一样，都是
print "The mapped array: @array_after_map\n";
print "The mapped array at 20190325 is : @array_20190325\n";

***************
5.4.8. The pop Function
The pop function pops off the last element of an array and returns it. The array size is subsequently decreased by 1 
pop(ARRAY)
pop ARRAY

#两种实现形式都可以
$pop_162=pop(@array_161);
print "The string of pop for array_161 is: $pop_162 .\n";
print "The string of pop for20190325  is:" , pop @array_161, ".\n";


********
5.4.9. The push Function
The push function pushes values onto the end of an array, thereby increasing the length of the array.
push(ARRAY, LIST)

push(@names, "Jim", "Joseph", "Archie");


**********
5.4.10. The shift Function
The shift function shifts off and returns the first element of an array, decreasing the size of the array by one element. If ARRAY is omitted, then the ARGV array is shifted, and, if in a subroutine, the @_ array is shifted. 移除数组的第一个函数。 移除最后一个用的是pop函数

shift(ARRAY)
shift ARRAY
shift

$shift_1=shift @array_172;


*********************
5.4.11. The splice Function
The splice function removes and replaces elements in an array. 移除数组元素，（或者移除后也替换上新的元素）

splice(ARRAY, OFFSET, LENGTH, LIST)
splice(ARRAY, OFFSET, LENGTH)
splice(ARRAY, OFFSET)

OFFEST是开始位置（就是从第几个数组元素开始)，length 是要替换的长度（其实是数组元素的个数），LIST是The LIST consists of new elements that are to replace the old ones，其实就是把原数组里移除了的数据用这个list里的元素补充上。 见下面第二个栗子

#####
@discarded = splice(@colors, 2, 2);

#### 另一个栗子：
1   @colors=("red", "green", "purple", "blue", "brown");
2   print "The original array is @colors\n";
3   @lostcolors=splice(@colors, 2, 3, "yellow", "orange"); # 把这俩元素填补上移除的那三个。只补上了两个，当然。
4   print "The removed items are @lostcolors\n";
5   print "The spliced array is now @colors\n";

(Output)
2   The original array is red green purple blue brown 
4   The removed items are purple blue brown # offset is initially 0， so starting at offset 2 ( the third element) 从第三个元素开始，总共3个
5   The spliced array is now red green yellow orange # 注意这里的输出


*************

5.4.12. The split Function

The split function splits up a string (EXPR) by some delimiter (whitespace by default) and returns an array. 把数组元素用指定的分隔符，依据指定的表达式来分割。 分割成几个串可以用 limit来定义，比如本来可以分成5个，可就设定为2个，那最后一个就把从第二个分隔符开始的都包含进去了。
split("DELIMITER",EXPR,LIMIT)
split(/DELIMITER/,EXPR,LIMIT)
split(/DELIMITER/,EXPR)
split("DELIMITER",EXPR)
split(/DELIMITER/) ## 默认的知道哪个是当前数组的情况  while(<DATA>){ @line=split(":");....
split

DELIMITER是分割符，默认是空白分割（空格、　tab 或回车换行符）， eXPR是要分割的串，limit是the number of fields that can be split

#一个栗子
1   $line="a b c d e";
2   @letter=split(' ',$line);

#两个栗子：
        while(<DATA>){
     1       ($name,$phone,$address,$bd,$sal)=split(":");
     2       print "$name\t $phone\n" ;
         }
_ _DATA_ _
......

#三个栗子
1   $string= "Joe Blow:11/12/86:10 Main St.:Boston, MA:02530";
6   @str=split(":", $string, 2);
7   print $str[0],"\n";  # The first element of the array
8   print $str[1],"\n";  # The rest of the array because limit is 2
9   print $str[2],"\n";  # Nothing is printed
#因为指定为分割为两个（limit），所以第二个字段就把所有的剩下的都划在里面了。

********
5.4.13. The sort Function

sort(SUBROUTINE LIST)
sort(LIST)
sort SUBROUTINE LIST
sort LIST

The sort function doesn't change the orginial list.

If SUBROUTINE is specified, the first argument to sort is the name of the subroutine, followed by a list of values to be sorted. 如果指定了subroutine，那么第一个参数就是要怎么来排序的这个子函数，下一个参数才是要应用这个子函数的逻辑来排序的目标串

If the string "cmp" operator is used, the values in the list will be sorted alphabetically (ASCII sort),(cmp是字符比较） and if the <=> operator (called the "space ship" operator) is used, the values will be sorted numerically. （《=》是数学比较）

The subroutine returns an integer less than, equal to, or greater than 0. The values are passed to the subroutine by reference and are received by the special Perl variables $a and $b, not the normal @_ array. 这个子函数会根据比较结果返回01-1一类的值，用来传递回$a $b 所以这俩是有特殊意义的，别随便定义修改它们。
(See subroutines in Chapter 11 for further discussion.) Do not try to modify $a or $b, as they represent the values that are being sorted.

#栗子：ASCII and Numeric Sort Using Subroutine
1 @list=("dog","cat", "bird","snake" );
  print "Original list: @list\n";
   # ASCII sort using a subroutine
2  sub asc_sort{
3          $a cmp $b;  # Sort ascending order。如果要降序，就是$b cmp $a
   }
4  @sorted_list=sort asc_sort(@list);
   print "Ascii sort: @sorted_list\n";

   # Numeric sort using subroutine
5  sub numeric_sort {
       $a <=> $b ;
   }  ######## $a and $b are compared numerically，是升序的，If $a and $b are reversed (e.g., $b <=> $a), then the sort is done in numeric descending order

6  @number_sort=sort numeric_sort 10, 0, 5, 9.5, 10, 1000;
   print "Numeric sort: @number_sort.\n";


####Using an Inline Function to Sort a Numeric List 把小子函数直接写进一个命令里：
1   @sorted_numbers= sort {$a <=> $b} (3,4,1,2);
2   print "The sorted numbers are: @sorted_numbers", ".\n";
####
@array=sort {$a cmp $b} Anna,Holy,Chris,Emma;   字符如此。


*********
5.4.14. The reverse Function
The reverse function reverses the elements in an array

@reversed=reverse(@names),"\n";

********
5.4.15. The unshift Function
The unshift function prepends LIST to the front of the array. 在一个数组前插入元素，所以插入的元素会在数组的开头 在结尾追加元素是用push函数。

1   @names=("Jody", "Bert", "Tom") ;
2   unshift(@names, "Liz", "Daniel");
3   print "@names\n";

(Output)
3   Liz Daniel Jody Bert Tom





************

5.5. Hash (Associative Array) Functions

************
5.5.1. The keys Function
The keys function returns, in random order, an array whose elements are the keys of a hash 随机的返回键值，组成数组。

2   foreach $key ( keys(%weekday) ){print "$key ";}。#随机打印。
    print "\n";
3   foreach $key ( sort keys(%weekday) ){print $key ;}
    print "\n";

**********
5.5.2. The values Function
The values function returns, in random order, an array consisting of all the values of a hash. 随机返回内容，组成数组

foreach $value ( values(%weekday)){print "$value";}

********
5.5.3. The each Function
The each function returns, in random order, a two-element array whose elements are the key and the corresponding value of a hash.

while(($key,$value)=each(%weekday)){
3      print "$key = $value\n";



**********
5.5.4. Sorting a Hash

按照健字母顺序排序很容易，用内嵌的sort函数就可以完成，可如果按照内容（values）排序，就有点麻烦了，需要用子函数来排。方法和数组部分讲的sort方法差不多。规则和禁戒也相同。

*******Sort Hash by Keys in Ascending Order

To perform an Ascii or alphabetic sort on the keys in a hash is relatively easy. The sort() function is given a list of keys and returns them sorted in ascending order. A foreach loop is used to loop through the hash one key at a time。 

foreach $value_289(reverse sort (%h_264))
{
    print "$value_289 , $h_264{$value_289} \n";
}


*****Sort Hash by Keys in Reverse Order

foreach $keys ( reverse sort keys %h_264)
{
    print "--reverse----$keys-----$h_264{$keys}\n";
}

*********Sort Hash by Keys Numerically

# numerically
foreach $keys ( sort {$b <=> $a} keys %h_264)  {print "-numerically-----$keys-----$h_264{$keys}\n";}
#alphabetically
foreach $keys ( sort {$a cmp $b} keys %h_264)  {print "-alphabetically-----$keys-----$h_264{$keys}\n";}

**********Numerically Sort a Hash by Values in Ascending Order
#要用一个子函数，把哈希的values进行排序，方法是通过键值，sub hash_sort{$hash{$a} <=> $hash{$b};} 可以直接内嵌，就成了下面这样的。不要用values直接来做，因为那样只有values， 你怎么得到keys啊，没有keys ，哈希也不好使了啊
foreach $keys(sort { $h_305{$a} <=> $h_305{$b} } ( keys (%h_305)))
{
    print "sort by value numerically: $keys---$h_305{$keys}.\n";
}

**********Numerically Sort a Hash by Values in Descending Order

sub hash_desc_sub
{
    $h_305{$b} <=> $h_305{$a};
}
foreach $keys( sort hash_desc_sub keys %h_305 )
{
    print "sort by value numerically descending: $keys---$h_305{$keys}.\n";
}




*************
5.5.5. The delete Function

The delete function deletes a value from a hash. The deleted value is returned if successful 返回值就是那个被删除掉的value

  $layoff=delete $employees{"Janitor"};
    print "We had to let $layoff go.\n";
#然后剩下：
    while(($key, $value)=each(%employees)){
       print "$key: $value\n";
    }

*************
5.5.6. The exists Function
The exists function returns true if a hash key (or array index) has been defined, and false if not.

print " exist Friday-> $h_305{Friday} \n" if exists $h_305{Friday};



************************
************************

Chapter 6. Where's the Operator?

***********************
*************************


*******
6.3.1. Assignment Operators

$var += 3;
print "\$var += 3 is $var \n";

$var -= 1;
print "\$var -=  1 is $var \n";

$name .="ny";
print "the full of \$name is  $name \n";

$line x= 10;
print "$line\n";

printf "\$var is %.2f\n",$var=4.2 + 2.3 ;

(Output)

$var += 3 is 3 
$var -=  1 is 2 
the full of $name is  Danny 
**********
$var is 6.50


********
6.3.2. Relational Operators

Relational operators are used to compare operands. The result of the comparison is either true or false.[3] Perl has two classes of relational operators: one set that compares numbers and another that compares strings.  比较操作数，返回真或假，有两套，一套比较字符串，另一套比较数字。

Relational Operators and Numeric Values
Operator	Example	Meaning
>		$x > $y   $x is greater than $y
>=		$x >= $y	$x is greater than or equal to $y
<		$x < $y	$x is less than $y
<=		$x <= $y	$x is less than or equal to $y


Relational Operators and String Values
Operator	Example			Meaning
gt		$str1 gt $str2		$str1 is greater than $str2
ge		$str1 ge $str2		$str1 is greater than or equal to $str2
lt		$str1 lt $str2		$str1 is less than $str2
le		$str1 le $str2		$str1 is less than or equal to $str2


Equality Operators and Numeric Values
Operator	Example			Meaning
==		$num1 == $num2		$num1 is equal to $num2
!=		$num1 != $num2		$num1 is not equal to $num2
<=>		$num1 <=> $num2		$num1 is compared to $num2 with a signed return; 1 if $num1 is greater than $num2, 0 if $num1 is equal to $num2, and -1 if $num1 is less than $num2

Equality Operators and String Values
Operator	Example			Meaning
eq		$str1 eq $str2		$str1 is equal to $str2
ne		$str1 ne $str2		$str1 is not equal to $str2
cmp		$str1 cmp $str2		$str1 is compared to $str2, with a signed return


#### Don't use == when you should use eq!
1   $x = "yes";
    $y = "no";
    print "\nIs yes equal to no? If so, say 1; if not say 'null'.\n";
2   print "The result is: ",$x == $y,"\n";    # Should be $x eq $y

(Output)
1   Is yes equal to no? If so, say 1; if not say 'null'.
2   The result is: 1. # 其实应该返回0才对，这样 yes居然等于no了。所以对串比较，千万别用==那是比较数字的。



##############
6.3.4. Logical Operators (Short-Circuit Operators)

Operator	Alternative Form	Example		Meaning
&&			and			$x && $y		If $x is true, evaluate $y and return $y
 	 					$x and $y		If $x is false, evaluate $x and return $x
||			or			$x || $y		If $x is true, evaluate $x and return $x
 	 					$x or $y		If $x is false, evaluate $y and return $y
 			xor			$x xor $y		True if $x or $y is true, but not both
!			not			! $x			Not $x; true if $x is not true
 	 					not $x	 

######Arithmetic Operators
Operator	Example	Meaning
+		$x + $y	Addition
-		$x - $y	Subtraction
*		$x * $y	Multiplication
/		$x / $y	Division
%		$x % $y	Modulus
**		$x ** $y	Exponentiation


######6.3.7. Autoincrement and Autodecrement Operators

Example	Description	Equivalence
++$x		Preincrement	$x = $x + 1
$x++		Postincrement	$x = $x + 1
--$x		Predecrement	$x = $x - 1
$x--		Postdecrement	$x = $x - 1


Autoincrement and Autodecrement Operators and Assignment
Example						Description	 							Equivalence			Result
If $y is 0 and $x is 0: $y = $x++;	Assign the value of $x to $y, then increment $x	$y = $x; $x = $x + 1;	$y is 0 $x is 1
If $y is 0 and $x is 0: $y = ++$x;	Increment $x, then assign $x to $y				$x = $x + 1; $y = $x;	$x is 1 $y is 1
If $y is 0 and $x is 0: $y = $x--;	Assign the value of $x to $y, then decrement $x	$y = $x; $x = $x - 1;	$y is 0 $x is -1
If $y is 0 and $x is 0: $y = --$x;	Decrement $x, then assign $x to $y				$x = $x - 1; $y = $x;	$x is -1 $y is-1


######6.3.8. Bitwise Logical Operators


 Bitwise Logical Operators

Operator	Example	Meaning
&		$x & $y	Bitwise and
|		$x | $y	Bitwise or
^		$x ^ $y	Bitwise exclusive or
<<		$x << 1	Bitwise left shift, integer multiply by two
>>		$x >> 1	Bitwise right shift, integer divide by two


Resulting Values of Bitwise Operators

$x	$y	$x & $y	$x | $y	$x ^ $y
0	0		0		0	0
0	1		0		1	1
1	0		0		1	1
1	1		1		1	0

***************
6.3.9. Conditional Operators
conditional expression ? expression : expression
$x ? $y : $z

**************
6.3.10. Range Operator
The range operator is used in both scalar and array context. In a scalar context, the value returned is a Boolean, 1 or 0. In an array context, it returns a list of items starting on the left side of the operator and counting by ones until the value on the right-hand side is reached.标量和数组都可以用。标量应用中，返回布尔值，0或1.数组中，返回范围内的值称为一个列表。


***********
6.3.11. Special String Operators and Functions

String Operations
Example					Meaning
$str1 . $str2				Concatenate strings $str1 and $str2
$str1 x $num				Repeat $str1, $num times
substr($str1, $offset, $len)	Substring of $str1 at $offset for $len bytes
index($str1, $str2)			Byte offset of string $str2 in string $str1
length(EXPR)				Returns the length in characters of expression, EXPR
rindex($str, $substr, POSITION)		Returns the position of the last occurrence of $substr in $str.
							If POSITION is specified, start looking there.
							If POSITION is not specified, start at the end of the string.
chr(NUMBER)				Returns the character represented by that NUMBER in the ASCII character set. For example, chr(65) 							is the letter A.
lc($str)					Returns a lowercase string
uc($str)					Returns an uppercase string


*********
6.3.12. Arithmetic Functions

Built-in Perl Arithmetic Functions
atan2(Y,X)					Returns the arctangent of Y/X in the range â€“PI to PI.
cos(EXPR) cos EXPR			Returns the cosine of EXPR (expressed in radians). If EXPR is omitted, takes cosine of $_.
exp(EXPR) exp EXPR			Returns e to the power of EXPR. If EXPR is omitted, gives exp($_).
int(EXPR) int EXPR			Returns the integer portion of EXPR. If EXPR is omitted, uses $_.
log(EXPR) log EXPR			Returns logarithm (base e) of EXPR. If EXPR is omitted, returns log of $_.
rand(EXPR) rand EXPR rand			Returns a random fractional number between 0 and the value of EXPR. (EXPR should be positive.) 							If EXPR is omitted, returns a value between 0 and 1. See also srand().
sin(EXPR) sin EXPR			Returns the sine of EXPR (expressed in radians). If EXPR is omitted, returns sine of $_.
sqrt(EXPR) sqrt EXPR			Return the square root of EXPR. If EXPR is omitted, returns square root of $_.
srand(EXPR) srand EXPR		Sets the random number seed for the rand operator. If EXPR is omitted, does srand(time).


*******Generating Random Numbers

As described in an article by Ian Goldberg and David Wagner concerning Web security, truly random numbers can be found only in nature, such as the rate of decay of a radioactive element.

The srand function sets the random number seed for the rand function but is no longer required if you are using a version of Perl greater than 5.004. A seed is a random number itself that is fed to the random number generator as the starting number from which new random numbers are produced.

while ($num)
{
    $rand_164=int(rand($num)) + 1;
    print "The rand nuber is $rand_164 \n";
    $rand_167=rand + 1;
    print "The rand number of nake rand is $rand_167 \n";
    sleep 3;
    $num--;
}


***************************

Chapter 7. If Only, Unconditionally, Forever

***************************


Foreach
The foreach loop iterates over each element in the parenthesized list, an array, assigning each element of the array to a scalar variable, one after the other, until the end of the list.

The VARIABLE is local to the foreach block. It will regain its former value when the loop is exited. Any changes made when assigning values to VARIABLE will, in turn, affect the individual elements of the array. If VARIABLE is not present, the $_ special scalar variable is implicitly used.

foreach VARIABLE (ARRAY)
{BLOCK}

*******
7.2.5. Loop Control


********
7.2.6. The switch Statement

switch (expression) {
  case value1 :
     /* statements */
     break;
  case value2 :
     /* statements */
     break;
  case value3 :
     /* statements */
     break;
  default:
     /* statements */
     break;
}



****************
******************

Chapter 8. Regular Expressionsâ€”Pattern Matching

*******************
******************


**********
8.2.2. The DATA Filehandle
In the following examples, the special filehandle called DATA is used as an expression in a while loop. This allows us to directly get the data from the same script that is testing it, rather than reading input from a separate text file. (You will learn all about filehandles in Chapter 10, "Getting a Handle on Files.") 

while(<DATA>){.   # ($_=<DATA>) and ($inputline=<DATA>) 也都可以
    Do something with the data here
}
_ _DATA_ _
    The actual data is stored here



*******
The unless Modifier

Expression2 unless Expression1;

$x=5;


   print $x unless $x == 6;


*********8.2.3. Looping Modifiers



1   $x=1;
2   print $x++,"\n" while $x != 5;

1   $x=1;
2   print $x++,"\n" until $x == 5;

1   @alpha=(a .. z, "\n");
2   print foreach @alpha;


***************
8.3. Regular Expression Operators
************

******8.3.1. The m Operator and Matching
用来指定分隔符，如果是// 可以不用m.，//是默认的分隔符
/Regular Expression/     default delimiter
m#Regular Expression#    optional delimiters
m{regular expression}    pair of delimiters

Matching Modifiers
Modifier	Meaning
i		Turn off case sensitivity.
m		Treat a string as multiple lines.
o		Compile pattern only once. Used to optimize the search.
s		Treat string as a single line when a newline is embedded.
x		Permit comments in a regular expression and ignore whitespace.
g		Match globally; i.e., find all occurrences. Return a list if used with an array context, or true or false if a scalar context.

**********
The g Modifier Global Match

1   $_ = "I lost my gloves in the clover, Love.";
2   @list=/love/g;

*******The i Modifier Case Insensitivity

1   $_ = "I lost my gloves in the clover, Love.";
2   @list=/love/gi;
3   print "@list.\n";


*******Special Scalars for Saving Patterns
The $ & special scalar is assigned the string that was matched in the last successful search. &` saves what was found preceding the pattern that was matched, and &' saves what was found after the pattern that was matched.
$&存最后匹配上的内容，&` 存之前的，&'存之后的


*******The x Modifier The Expressive Modifier
The x modifier allows you to place comments within the regular expression and add whitespace characters (spaces, tabs, newlines) for clarity without having those characters interpreted as part of the regular expression; in other words, you can express your intentions within the regular expression.

$_= "We are the hope of the world";
print "Result is $&.\n" if /the    #looking for the patterns
/x;
这里的空格，注释都不影响结果


***********8.3.2. The s Operator and Substitution
The s operator is used for substitutions.

s/old/new/;
s/old/new/i;
s/old/new/g;
s+old+new+g;
s(old)/new/;   s[old]{new};
s/old/expression to be evaluated/e;
s/old/new/ige;
s/old/new/x;

Substitution Modifiers
Modifier	Meaning
e		Evaluate the replacement side as an expression.
i		Turn off case sensitivity.
m		Treat a string as multiple lines.[a]
o		Compile pattern only once. Used to optimize the search.
s		Treat string as single line when newline is embedded.
x		Allow whitespace and comments within the regular expression.
g		Replace globally; i.e., find all occurrences.


The e Modifier Evaluating an Expression
 while(<DATA>){
2       s/6/6 * 7.3/eg;       # Substitute 6 with product of 6 * 7.3
3       print; # 结果会是用6 * 7.3的结果代替6

#又一个栗子
s[knock]{"knock, " x 2 . "knocking"}ie;
#s/knock/"knock, " x 2 . "knocking"/ie;
print "He is $_\n";
（output)
He is knock, knock, knocking at heaven's door.


**********
8.3.3. Pattern Binding Operators	

Table 8.3. Pattern Matching Operators
Example				Meaning
$name =~ /John/			True if $name contains pattern. Returns 1 for true, null for false.
$name !~ /John/			True if $name does not contain pattern.
$name =~ s/John/Sam/		Replace first occurrence of John with Sam.
$name =~ s/John/Sam/g	Replace all occurrences of John with Sam.
$name =~ tr/a-z/A-Z/		Translate all lowercase letters to uppercase.
$name =~ /$pal/			A variable can be used in the search string.


#yige lixi:

$name="either IELTS or BEC is my tagert";
print $name ,"\n" if $name =~ tr/a-z/A-Z/;

(Output)
EITHER IELTS OR BEC IS MY TAGERT

# another good lixi:

1   while(<DATA>){
2       @line = split(":", $_);
3       print $line[0],"\n" if $line[1] =~ /408-/
                              # Using the pattern matching operator
    }
4   __DATA__.  #注意这里两个下滑线之间没空格
    Igor Chevsky:408-567-4444:3456 Mary Way

(Output)
Igor Chevsky

上面栗子也可以这样：
      ($name, $phone, $address) = split(":", $_);
3           print $name if $phone =~ /408-/



**************************
*************************

Chapter 9 正则疯狂匹配

************************
*************************

Regular expression metacharacters are characters that do not represent themselves. They are endowed with special powers to allow you to control the search pattern in some way (e.g., find the pattern only at the beginning of line or at the end of the line or only if it starts with an upper- or lowercase letter). Metacharacters lose their special meaning if preceded with a backslash (\). For example, the dot metacharacter represents any single character but when preceded with a backslash is just a dot or period.




Metacharacter	What It Matches
######Character Class: Single Characters and Digits

.			Matches any character except a newline
[a-z0-9]		Matches any single character in set
[^a-z0-9]		Matches any single character not in set
\d			Matches one digit
\D			Matches a nondigit, same as [^0-9]
\w			Matches an alphanumeric (word) character
\W			Matches a nonalphanumeric (nonword) character


#######Character Class: Whitespace Characters
\s			Matches a whitespace character, such as spaces, tabs, and newlines
\S			Matches nonwhitespace character
\n			Matches a newline
\r			Matches a return
\t			Matches a tab
\f			Matches a form feed
\b			Matches a backspace
\0			Matches a null character



######Character Class: Anchored Characters
\b			Matches a word boundary (when not inside [ ])
\B			Matches a nonword boundary
^			Matches to beginning of line
$			Matches to end of line
\A			Matches the beginning of the string only
\Z			Matches the end of the string or line
\z			Matches the end of string only
\G			Matches where previous m//g left off


########Character Class: Repeated Characters
x?			Matches 0 or 1 x
x*			Matches 0 or more occurrences of x
x+			Matches 1 or more occurrences of x
(xyz)+		Matches 1 or more patterns of xyz
x{m,n}		Matches at least m occurrences of x and no more than n occurrences of x


########Character Class: Alternative Characters
was|were|will	Matches one of was, were, or will


########Character Class: Remembered Characters
(string)		Used for backreferencing (see Examples 9.38 and 9.39)
\1 or $1		Matches first set of parentheses[a]
\2 or $2		Matches second set of parentheses
\3 or $3		Matches third set of parentheses



#########Character Class: Miscellaneous Characters
\12			Matches that octal value, up to \377
\x811			Matches that hex value
\cX			Matches that control character; e.g., \cC is <Ctrl>-C and \cV is <Ctrl>-V
\e			Matches the ASCII ESC character, not backslash
\E			Marks the end of changing case with \U, \L, or \Q
\l			Lowercase the next character only
\L			Lowercase characters until the end of the string or until \E
\N			Matches that named character; e.g., \N{greek:Beta}
\p{PROPERTY}	Matches any character with the named property; e.g., \p{IsAlpha}/
\P{PROPERTY}	Matches any character without the named property
\Q			Quote metacharacters until \E
\u			Titlecase next character only
\U			Uppercase until \E
\x{NUMBER}		Matches Unicode NUMBER given in hexadecimal
\X			Matches Unicode "combining character sequence" string
\[			Matches that metacharacter
\\			Matches a backslash



#####The Dot Metacharacter
The dot (.) metacharacter matches any single character with the exception of the newline character. 不能匹配换行

$_="Sing a song of sixpence\nA pocket full of rye.\n";
# print if /pence.A/s ;

print $& if /pence.A/s ;
print "\n";
print if s/sixpence.A/twopence, a/s;   # 前一个s是替换模式开关，后一个是令dot识别换行开关

(Output)
pence
A
Sing a song of twopence, a pocket full of rye.


########The s Modifier: The Dot Metacharacter and the Newline
The s modifier treats the line with embedded newlines as a single line, rather than a group of multiple lines, and allows the dot metacharacter to treat the newline character the same as any other character it might match. The s modifier can be used with both the m (match) and the s (substitution) operators.
 s 可以把换行\n也当作一个字符来处理，这样，dot(.)就可以匹配换行了。 可以和 m 匹配和s替换结合着来使用。
注意，这个转意s在后，替换s在前。见4.

1   $_="Sing a song of sixpence\nA pocket full of rye.\n";
2   print $& if /pence./s;
3   print $& if /rye\../s;
4   print if s/sixpence.A/twopence, a/s;

(Output)
2   pence
3   rye.
4   Sing a song of twopence, a pocket full of rye.


#########Metacharacters that Turn off Greediness
By placing a question mark after a greedy quantifier, the greed is turned off, and the search ends after the first match 
rather than the last one.
在匹配模式后加一个？　就可以关闭贪婪模式，

1   $_="abcdefghijklmnopqrstuvwxyz";
2   s/[a-z]+/XXX/;
3   print $_, "\n";

4   $_="abcdefghijklmnopqrstuvwxyz";
5   s/[a-z]+?/XXX/;
6   print $_, "\n";

(Output)
3   XXX
6   XXXbcdefghijklmnopqrstuvwxyz

########Turning Off Greediness

x??		Matches 0 or 1 occurrences of x
(xyz)??		Matches 0 or 1 occurrences of pattern xyz
x*?		Matches 0 or more occurrences of x
(xyz)*?		Matches 0 or more occurrences of pattern xyz
x+?		Matches 1 or more occurrences of x
(xyz)+?		Matches 1 or more occurrences of pattern xyz
x{m,n}?		Matches at least m occurrences of x and no more than n occurrences of x
x{m}?		Matches at least m occurrences of x
x{m,}?		Matches at least m times


##########Table 9.7. Anchors (Assertions)

^	Matches to beginning of line or beginning of string
$	Matches to end of line or end of a string
\A	Matches the beginning of the string only
\Z	Matches the end of the string or line
\z	Matches the end of string only
\G	Matches where previous m//g left off
\b	Matches a word boundary (when not inside [ ])
\B	Matches a nonword boundary


1   while(<DATA>){
2       print if /\bJon/;
    }
    _ _DATA_ _
    Steve Blenheim 1.10
    Betty Boop .5
    Igor Chevsky 555.100
    Norma Cord 4.01
    Jonathan DeLoach .501
    Karen Evich 601

(Output)
Jonathan DeLoach .501
******The expression reads: Find a word beginning with the pattern Jon

所以下面这个没有输出：Find a word beginning and ending with Jon. Nothing is found.
1   while(<DATA>){
2       print if /\bJon\b/;
    }


########The m Modifier
用了m,可以把^ $ 这两个首位匹配 覆盖到换行\n, 否则，遇到换行，首位匹配就都不继续向下识别了，不过　m 对　/A和/z都是不起作用的！只对$^管用
A string containing newlines will be treated as multiple lines. If the regular expression is anchored with the ^ metacharacter,
 and that pattern is found at the beginning of any one of the multiple lines, the match is successful.

perl -e ' $_="Today is history.\nTomorrow will never be here.\n";print if /^Tomorrow/;'
----没结果
perl -e ' $_="Today is history.\nTomorrow will never be here.\n";print if /^Tomorrow/m;'
Today is history.
Tomorrow will never be here.
可以匹配出来


#########Alternation

print if /Steve|Betty|Jon/;


##########Grouping or Clustering（）
If the regular expression pattern is enclosed in parentheses, a subpattern is created
扩在括号里，就成为一个集群，可以最当做一个小单独个体来对待。 　（）

1   $_=qq/The baby says, "Mama, Mama, I can say Papa!"\n/;
2   print if s/(ma|pa)+/goo/gi;

(Output)
The baby says, "goo, goo, I can say goo!"
******:The expression reads: Find one or more occurrences of the pattern ma or pa and replace that with goo.


1   while(<DATA>){
2       print if /\s(12){3}$/;  # Print lines matching exactly 3
                                # consecutive occurrences of 12 at
                                # the end of the line
    }
    _ _DATA_ _
    Steve Blenheim  121212
    Betty Boop      123
    Igor Chevsky    123444123
    Norma Cord      51235
    Jonathan DeLoach123456
    Karen Evich     121212456

(Output)
Steve Blenheim 121212


2       # print if /^Steve|Boop/;It would print any line that begins with Steve and any line containing the pattern Boop.
                                 / 会打印出以Steve开头的行，以及包含　Boop的行，头标并不会作用到 Boop的。
3         print if /^(Steve|Boop)/; /这个才会把都是两个开头的行打出来。



#######Remembering or Capturing
把一个模式括在括号里，除了可以当作一个小独立个体外，另一个用途是，它们都被编号存在内存里了。想取出来用十分方便。
If the regular expression pattern is enclosed in parentheses, a subpattern is created. 
The subpattern is saved in special numbered scalar variables, starting with $1, then $2, and so on.


s/([Jj]on)/$1lathan/; /把　Jon或jon 替换为　Jonlathan or Jonathan 了。 

---
print if s/(Steve) (Fraze)/$2,$1/.  /把Steve Fraze替换为Fraze,Steve


1   while(<DATA>){
2       s/([A-Z][a-z]+)\s([A-Z][a-z]+)/$2, $1/;
                                       # Reverse first and last names
3       print;
    }
    _ _DATA_ _
    Steve Blenheim
    Betty Boop
    Igor Chevsky
    Norma Cord
    Jon DeLoach
    Karen Evich

  # 这段会把一行的名和姓点颠倒输出。 不过在第五个会遇到麻烦。输出是De Jon. 解决方法：  s/([A-Z][a-z]+)\s([A-Z][A-Za-z]+)/$2, $1/;

# The following works the same:
   s/(\w+)\s(\w+)/$2,$1/;

#and:
2       ($first, $last)=/(\w+) (\w+)/;   # Could be: (\S+) (\S+)/
3       print "$last, $first\n";


#

1   $string="ABCdefghiCxyzwerC YOU!";
2   $string=~s/.*C/HEY/;
3   print "$string", "\n";
#/.*C/, reads: Find the largest pattern that contains any number of characters ending in C. This search is greedy.
 It will search from left to right until it reaches the last C. 

(Output)
HEY YOU!

######## a good example of ? Turn off greedy modes
1   $fruit="apples pears peaches plums";
2   $fruit =~ /(.*)\s(.*)\s(.*)/;
3   print "$1\n";
4   print "$2\n";
5   print "$3\n";
    print "-" x 30, "\n";
6   $fruit="apples pears peaches plums";
7   $fruit =~ /(.*?)\s(.*?)\s(.*?)\s/; # Turn off greedy quantifier
8   print "$1\n";
9   print "$2\n";
10  print "$3\n";

(Output)
3   apples pears
4   peaches
5   plums
    ------------------------------
8   apples
9   pears
10  peaches

The string is divided into three remembered substrings, each substring enclosed within parentheses. The .* metacharacter sequence reads zero or more of any character. The * always matches for the largest possible pattern. The largest possible pattern would be the whole string. However, there are two whitespaces outside of the parentheses that must also be matched in the string. What is the largest possible pattern that can be saved in $1 and still leave two spaces in the string? The answer is apples pears.
第一个匹配，.*会匹配最大可能。括号把他们分成三部分，留下剩下两部分，第一个就会存下apples pears.
This time, a question mark follows the greedy quantifier (*). This means that the pattern saved will be the minimal, rather than the maximal, number of characters found. apples will be the minimal numbers of characters stored in $1, pears the minimal number in $2, and peaches the minimal number of characters in $3. The \s is required or the minimal amount of characters would be zero, since the * means zero or more of the preceding character.
第二个匹配，?关闭了贪婪模式，所以.* 会匹配最小的符合条件。那就是只有apples. 最后要加一个\s  否则，最小的匹配会是空，而不会是peaches.


########turn off capturing  关闭分组存储
如果只想用括号来分组，并不打算存在$1 $2等里，那么可以用　？：来关闭存储的方式。只保留分组的功能
When the only purpose is to use the parentheses for grouping, and you are not interested in saving the subpatterns in $1, $2, or $3, the special ?: metacharacter can be used to suppress the capturing of the subpattern.

#:
$_="Tom Savage and Dan Savage are brothers.\n";
print if /(?:T[a-z]*)/;
print "$1\n";

OUTPUT:
Tom Savage and Dan Savage are brothers.
Use of uninitialized value $1 in concatenation (.) or string at ./9_2_re.pl line 66.


################Metacharacters that Look Ahead and Behind

/PATTERN(?=pattern)/	Positive look ahead
/PATTERN(?!pattern)/	Negative look ahead
(?<=pattern)/PATTERN/	Positive look behind
(?<!pattern)/PATTERN/	Negative look behind


#
$string="I love chocolate cake and chocolate ice cream.";
$string =~ s/chocolate(?= ice)/vanilla/;
print "$string \n";

OUTPUT
I love chocolate cake and vanilla ice cream. （注意只有chocolate被替换，后面的ice只是做为查找限定的条件，并不会被替换！！！！！！！！！）

# a negative ahead :
print if/^\w+\s(?![BC])/;    一个词，一个空格，然后不能是 B或C开头的。

# A positive look behind

1   $string="I love chocolate cake, chocolate milk,
             and chocolate ice cream.";
2   $string =~ s/(?<= chocolate) milk/ candy bars/;
OUTPUT：
 I love chocolate cake, chocolate candy bars, and chocolate ice cream.
如果milk	前是 chocolate，milk，注意是milk，而不是chocolate milk 将被替换为candy bars！！！！！！！！

### negative look behind
 print if /(?<!Betty) B[a-z]*/;



##########

9.1.4. The tr or y Function


tr Modifiers
Modifier	Meaning
d		Delete characters
c		Complement the search list
s		Squeeze out multiple characters to single character



Format
tr/search/replacement/
tr/search/replacement/d
tr/search/replacement/c
tr/search/replacement/s
y/search/replacement/      (same as tr; uses same modifiers)


##
 tr/a-z/A-Z/;print;

### c:

  while(<DATA>){
       tr/0-9/*/c; print;
}
__DATA__
Steve Blenheim 101
Betty Boop  202

OUTPUY:
***************101*
************202*

把所有不在串里的字符，都替换成了目标字符，也就是所有不是数字的，都替换成*了。 （多么诡异的功能！！！）
The c (complement) option complements the search string; that is, it translates each character not listed in this string to its corresponding character in the replacement string.


###The tr Squeeze Option
把相同的符号压缩成只剩下一个
while (<DATA>){
        tr/:/:/s;
        print;
    {
    _ _DATA_ _
    1:::Steve Blenheim
    2::Betty Boop
    3:Igor Chevsky
    4:Norma Cord
    5:::::Jon DeLoach
    6:::Karen Evich

(Output)
1:Steve Blenheim
2:Betty Boop
3:Igor Chevsky
4:Norma Cord
5:Jon DeLoach
6:Karen Evich
其实是替换成只有一个：。如果不用：，就会替成那个新的，比如-
非常好用！！！！！！！

The end of Chapter 9



###################################
#######  Chapter 10.   ###########
##################################



### 10.1.2 Open for reading
1   open(FILEHANDLE, "FILENAME");
2   open(FILEHANDLE, "<FILENAME");
2   open(FILEHANDLE);
3   open FILEHANDLE;

#### Closing the filehandle
close (FILEHANDLE);
close FILEHANDLE;

If you don't explicitly close the file, when you reopen it this way, the line counter variable, $., will not be reset. 
Closing a pipe causes the process to wait until the pipe is complete and reports the status in the $! variable
不及时关闭句柄问题多多哦

####### die function 

the die function is used if a call to the open function fails. If Perl cannot open the file, the die function is used 
to exit the Perl script and print a message to STDERR, usually the screen.
如果打开文件失败，die函数会推出perl程序，并将出错信息写入　STDERR

a special variable $! to hold the value of the system error that occurs when you are unable to successfully open a file 
or execute a system utility.
$!会用来存储出错的信息

open (FILE1,"hellohaha") || die " I cannot open the file ." ;
OUTPUT: I cannot open the file . at ./10_file.pl line 72, <DB> line 6.

open (FILE1,"hellohaha") || die " I cannot open the file .\n" ;
OUTPUT: I cannot open the file .

open (FILE1,"hellohaha") || die " I cannot open the file . $!\n" ;
OUTPUT: I cannot open the file . No such file or directory

Note: The \n suppresses any further output from the die function. All of die's output is sent to STDERR 
after the program exits.
Omitting the \n causes the die function to append a string to the output, indicating the line number 
in the script where the system error occurred.


\n会只把die的内容显示，并存到STDERR句柄。如果不加，会把错误发生的具体位置也展示出来
而$!里，存着具体的出错原因。他们会一起被写入　STDERR



#########Reading from the Filehandle

1   open(FILE, "datebook") || die "Can't open datebook: $!\n";
2   while(<FILE>) {
3       print if /Sir Lancelot/;
4   }
5   close(FILE);

--
while($line = <FILE>) 
---
@lines = <FILE>;

--	

#########Open for writing 

Format
1   open(FILEHANDLE, ">FILENAME)";

1.  $file="/home/jody/ellie/perl/newfile"; 
2   open(HANDOUT, ">$file") || die "Can't open newfile: $!\n";
3   print HANDOUT "hello world.\n";
4   print HANDOUT "hello world again.\n";

###########Open for appending 
open(FILEHANDLE, ">> FILENAME");

########### select ： 改变当前句柄的函数，很好用的函数！！！

用select 函数，把当前句柄设置为默认句柄，所有输入输出都会操作在这个句柄对应的文件中。它的返回值为前一个句柄。

改变当前句柄，就表示，可以把要操作的输出的内容，打印到另一个文件里，只要把另一个文件的句柄设置为当前句柄。


open (FILEOUT,">newfile")  || die "Can't open newfile: $!\n"; 
select(FILEOUT);# 以前的默认句柄是STDOUT，现在变成了　FILEOUT

如果这样写 $oldfile=select(FILEOUT）, 那么，当前句柄仍被改为　FILEOUT，　但$filefile里存的变量是前一个句柄，也就是STDOUT，即屏幕。


(The Script)
    #! /usr/bin/perl
1   open (FILEOUT,">newfile")  || die "Can't open newfile: $!\n";
2   select(FILEOUT);      # Select the new filehandle for output
3   open (DB, "<datebook") || die "Can't open datebook: $!\n";
    while(<DB>) {
4      print ;            # Output goes to FILEOUT, i.e., newfile 文件内容会被打入进当前的句柄　FILEOUT。
    }
5   select(STDOUT);       # Send output back to the screen #再把当前句柄设置回来，到屏幕。
    print "Good-bye.\n";  # Output goes to the screen

# 



#########File Locking with flock：文件锁操作。
To prevent two programs from writing to a file at the same time, you can lock the file so you have exclusive access to it and then unlock it when you're finished using it. The flock function takes two arguments: a filehandle and a file locking operation
把正在操作的文件加保护锁，防止在自己写操作的时候，也有别人操作它而引起混乱

 File Locking Operations
Name	Operation	What It Does
lock_sh	1	Creates a shared lock
lock_ex	2	Creates an exclusive lock
lock_nb	4	Creates a nonblocking lock
lock_un	8	Unlocks an existing lock



1   $LOCK_EX = 2;
2   $LOCK_UN = 8;

3   print "Adding an entry to the datafile.\n";
    print "Enter the name: ";
    chomp($name=<STDIN>);
    print "Enter the address: ";
    chomp($address=<STDIN>);

4   open(DB, ">>datafile") || die "Can't open: $!\n";

5   flock(DB, $LOCK_EX) || die ;        # Lock the file

6   print DB "$name:$address\n";

7   flock(DB, $LOCK_UN) || die;         # Unlock the file



#############The seek and tell Functions 
seek是个好函数。

the seek function allows you to move to some byte (not line) position within the file. The seek function returns 1 if successful, 0 otherwise

可以在随意的位置开始文件操作。position： 0 代表文件开头，2代表结尾，1代表当前位置
offset是从position开始的文件的（偏移）位置。可前可后，前为正，后为负

seek(FILEHANDLE, BYTEOFFSET, FILEPOSITION);

The seek function sets a position in a file, where the first byte is 0. Positions are

0 = Beginning of the file

1 = Current position in the file

2 = End of the file

BYTEOFFSET是偏移量。可正可负。 seek(FH,-13,2)： 从末尾，向回13个字符的位置。

用od命令可以显示文件是怎么存储的，unix里回车换行等用\n 

例子：
open (DB,"<datafile") or die "Cannot open the file: $! \n";

while ( $line=<DB>)
{
    if ($line =~ /Lori/)
    {
        print "---$line---\n";
    }
} 

seek(DB,0,0); #如果这里不用seek， 那么想进行下面的操作，必须先把文件关了，再打开。 用了seek， 可以定位到指定位置，对这个例子，回到文件开头，从第一个字符开始。

while (<DB>)
{
    print if /Tommy/;
} 


----
seek(FH,0,1) or die; 当前位置	

----
1   open(FH, "db") or die "Can't open datebook: $!\n";
2   seek(FH,-13,2) or die;
3   while(<FH>){
4       print;
    }

(Output)
4   Karen Evich
从文件末尾开始，向前数13位，恰好是　Karen Evich
用od -c 命令 可以看处文件的存储。 Od -c db 


------
用　tell　命令，可以返回文件的当前字符位置，供seek函数使用。
The tell function returns the current byte position in the file and is used with the seek function to move to that 
position in the file. If FILEHANDLE is omitted, tell returns the position of the file last read.

tell(FILEHANDLE);
tell;

1   open(FH,"db") || die "Can't open: $!\n";
2   while ($line=<FH>) {      # Loop through the whole file
       chomp($line);
3      if ($line =~ /^Lori/) {
4          $currentpos=tell;  # 这个位置恰好是之前的匹配完成，下一个字符开始的位置。
5          print "The current byte position is $currentpos.\n";
6          print "$line\n\n";
       }
    }
7   seek(FH,$currentpos,0);   # Start at the beginning of the file
# 用新的到的位置做偏移量，从开头开始来过。 
8   @lines=(<FH>);
9   print @lines;

用　od -c db ，可以看出，这个位置恰好是匹配完LORI 的那一行后的下一行。 注意这里只能用tell得到的位置做偏移量。因为seek只有三个选项做位置：0，1，2
分别代表开头，当前位置和结尾。




######### Open for Reading and Writing 
　打开文件来读写
Reading and Writing Operations
Symbol		Open For
+<		Read first, then write
 	 "+<" 是先读后写，如果要在已有的文件中，添加数据但不是在文件末尾即在文件开始或中间添加数据，先用seek（）函数定位到要添加数据的位置，
	 然后开始在文件中写入数据
+>		Write first, then read
  	 "+>" 是先写后读，如果文件存在，先把文件的内容删除，再写入数据，然后再读。操作结果：文件中以前的数据被删除，现在文件中只保留目前写入的数据
+>>		Append first, then read


一个例子：
open(FH, "+>file") || die;
print FH "This line is written to file.\n";
seek(FH,0,0);         # Go to the beginning of the file
 while(<FH>) {
        print;            # Reads from file; the line is in $_
}

 file里的文件都被清空，最后只剩下新写入的这行：This line is written to file.


###########Open for Pipes
open a filter so that the output is piped to a system command. The command is preceded by a pipe symbol (|) and replaces the filename argument in the previous examples. The output will be piped to the command and sent to STDOUT.
打开的文件内容作为管道命令后的参数，输出默认是屏幕　STDOUT

open(FILEHANDLE,|COMMAND);


一个例子：
 open(MYPIPE, "| wc -w");
print MYPIPE "apples pears peaches";
 close(MYPIPE);
 这个句柄不需要有一个文件存在。，写入它的内容，会当作参数，管道给后面的一个系统命令。所以，这个输出的结果是3 

又一个例子：
1   open(FOO, "| tr '[a-z]' '[A-Z]'");
2   print FOO "hello there\n";
3   close FOO;   # If you don't close FOO, the output may be delayed

(Output)
2   HELLO THERE



再来一个好例子，把文件里的内容全部转换大小写：
$ cat emp.names
1 Steve Blenheim
2 Betty Boop
3 Igor Chevsky
4 Norma Cord
5 Jon DeLoach
6 Karen Evich

(The Script)
    #!/usr/bin/perl
1   open(FOO, "| sort  +1| tr '[a-z]' '[A-Z]'"); # Open output filter
2   open(DB, "emp.names");       # Open DB for reading
3   while(<DB>)
   { print FOO ; }
4   close FOO;


#########Sending the Output of a Filter to a File (需要再看看！！@@###）	
想把管道输出定向到文件里，而不是像上面一样屏幕输出。那就把STDOUT重定向到一个句柄吧。

open(STDOUT, ">/dev/tty");



####################Input Filter （ 很好用的！）
把一个命令的输出，存储在句柄里。
open(FILEHANDLE, COMMAND|);

一个栗子
1   open(INPIPE, "date |");    
2   $today = <INPIPE> ";
3   print $today;
4   close(INPIPE);

(Output)
Thu Aug 29 09:21:47 CST 2019



再一个栗子：

open (OPENGREP,"find . -size +2k -mtime +20 -exec ls  {} \\;|");
while($filegrep=<OPENGREP>)
{
    print $filegrep;
}

(OUTPUT)
./7_if_only.pl
./5_what_is_in_a_name.pl
./6_whereisoperator.pl
./6_exercise_1-8.pl





######################10.2. Passing Arguments######################

ARGV是一个句柄	

ARGV[0]:	 the name of the first word after the script name 第一个参数（如果是）
$0      :	 is used to hold the name of the Perl script.     脚本名
$#ARGV  : 	 contains the number of the last subscript in the array.最后一个参数 
$#ARGV + 1  	 The number of arguments.参数个数

$ARGV :		contains the name of the currently selected filehandle. <ARGV>里的当前值


一个栗子：
die "$0 requires an argument.\n" if $#ARGV < 0 ;

print "@ARGV\n";
print "$ARGV[1]\n";
print "$ARGV[$#ARGV] is the last argument.\n";

（OUTPUT）
MCdeMacBook-Pro:perl mc$ ./10_file.pl a1 a2 a3 a4 a5(运行行）
a1 a2 a3 a4 a5
a2
a5 is the last argument.



#######
while( <ARGV> ) {print ;} 可以移动每个参数打印出来


####### 又一个栗子
$. 存贮现在的行数。

print "-----------\n";
if ( $#ARGV < 1 )
{
    die " $0: pattern filename(s).\n";
}

$pattern=shift;

while ($line=<ARGV>)
{
    print "$ARGV: $. : $line " if $line =~ /$pattern/i;
    close(ARGV) if eof;
}

=OUTPUT
data: 6 : Karen Evich 601
 db: 7 : Karen Evich

###############练习题B的第三题非常好：找出12小时内修改了的文件，
用stat 函数。利用现在时间和修改时间减，得出修改的间隔。都是是从1970年起的秒数。
和12小时的秒数相比，查找修改时间符合要求的：
     my $lmtimedate = (stat $myfile)[9];
     my $now = time();
     my $howLongAgo = $now - $lmtimedate; #Since epoch time is just a number of seconds, it's easy to calculate short distances in time. 60*60 = 1 hour * 12 = 12 hours.
    
    if ($howLongAgo <= (60*60*12))
    {
        print "$myfile was edited less than 12 hours ago.\n";
    }

PS#### stat 的值
my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
        $atime,$mtime,$ctime,$blksize,$blocks)
           = stat($filename);
OR：
use File::stat;
my $mtime = stat($filename)->mtime;





####################################################################
##################   Chapter 11 Subroutines.   #####################
####################################################################

#######local 和my 

 Any variable declared with local is said to be dynamically scoped, which means it is visible from within the block
 where it was created and visible to any functions called from within this block or any blocks (or subroutines) 
nested within the block where it is defined. If a local variable has the same name as a global variable, 
the value of the global one is saved and a new local variable is temporarily created. When the local variable 
goes out of scope, the global variable becomes visible again with its original value(s) restored. 
After the last statement in a subroutine is executed, its local variables are discarded. 
local 在申明的函数内，以及调用这个函数的自函数内均有效。
My  只在申明的函数内有效，调用的函数内无效。

一个栗子：
1   $friend="Louise";        # Global variables
2   $pal="Danny";
3   print "$friend and $pal are global.\n";
4   sub guests {
5       my $friend="Pat"; # Lexically scoped variable
6       local $pal="Chris";  # Dynamically scoped variable
7       print "$friend and $pal are welcome guests.\n";
8       &who_is_it;          # Call subroutine
    }

9   sub who_is_it {
10      print "You still have your global friend, $friend, here.\n";
11      print "But your pal is now $pal.\n";  # Dynamically scoped
    }

12  &guests;                 # Call subroutine
13  print "Global friends are back: $friend and $pal.\n";


##### 11.2.1: Prototypes
A prototype, also described as a template, tells the compiler how many and what types of arguments 
the subroutine should get when it is called.o call subroutines that have been declared with a prototype, 
the ampersand (&) must be omitted,
Prototypes 告诉编译器，函数要带几个参数，都是什么类型。不过，调用函数的时候，调用符号得省略，否则prototype不起作用。
换句话说，他可以在调用函数时，检查函数的参数定义。
一个栗子：
1   my $a=5;
    my $b=6;
    my $c=7;
2   @list=(100,200,300);
3   sub myadd($$) {       # myadd requires two scalar arguments
        my($x, $y)=@_;
        print $x + $y,"\n";
    }
4   myadd($a, $b);        # Okay
5   myadd(5, 4);          # Okay
6   myadd($a, $b, $c);    # Too many arguments



###### 11.2.2return value
$average    =  &ave(3, 5, 6, 20);
returned value    call to subroutine

The value returned is really the value of the last expression evaluated within the subroutine.
The return function can also be used to return a specified value or to 
return early from the subroutine based on some condition.

可以是最有一个表达式的值，或者是设定的返回值

一个栗子：
    sub MAX {
1       my($max) = shift(@_);
2       foreach $foo ( @_ ){
3           $max = $foo if $max < $foo;
            print $max,"\n";
        }
        print "------------------------------\n";
4       $max;
    }
    sub MIN {
        my($min) = pop( @_ );
        foreach $foo ( @_ ) {
            $min = $foo if $min > $foo;
            print $min,"\n";
        }
        print "------------------------------\n";
        return $min;
    }

5   my $biggest = &MAX ( 2, 3, 4, 10, 100, 1 );
6   my $smallest= &MIN ( 200, 2, 12, 40, 2, 20 );
7   print "The biggest is $biggest and the smallest is $smallest.\n";

所以，返回方式可以为如下两种：
 $max;
 return $min;


##### Context  上下文 	#####
perl对上下文是敏感的。 列表上下文与标量上下文。
scalar and list. When mixing data types, results differ when an expression is evaluated in one or the other context.
比如：
@list = qw( apples pears peaches plums );  # List context 这里会获得一个数组。
$number = @list;   #Scalar context。   这里得到的会是数组数量。 标量上下文





























