
###############
################

5章： what’s in a name

##################
##################

Single quotes are the "democratic" quotes. All characters enclosed within them are treated equally; in other words, there are no special characters. But the double quotes discriminate. They treat some of the characters in the string as special characters. The special characters include the $ sign, the @ symbol, and escape sequences such as \t and \n.
单引号里的一切都按原样打印出来，双引号会解释特殊字符，比如$ \t \n等。 所以要打印出特殊字符要放在单引号里。

If a string is enclosed in single quotes, it is printed literally (what you see is what you get).

　所见即所得。

*******
Curly Braces
可以替换变量。
1   $var="net";
2   print "${var}work\n";

(Output)
2   network

********
The $_ Scalar Variable: hold the default search pattern or the current line.:存贮当前值 
:::::::::: 
>perl -e ' $_="Christine"; print "$_\n";'
(Output:)
Christine


***********Arrays:**********
Perl doesn't care whether the elements of an array are of the same data type. They can be a mix of numbers and strings 数组类型是什么都可以，不要求所有元素一致。
@pals = ( "John", "Sam", "Nicky", "Jake" )；

The special scalar variable $#arrayname returns the number of the last subscript in the array. Since the array subscripts start at zero, this value is one less than the array size.  $#返回最后一个值的位置，可是因为数组从0开始计数，这个值比数组个数少1

***The Range Operator and Array Assignment ： 范围运算符，注意.. 前后均有空格
@digits=(0 .. 10);
 @letters=( 'A' .. 'Z' );
 @alpha=( 'A' .. 'Z', 'a' .. 'z' );
@n=( -5 .. 20 );


************
5.2.3. Hashes
**********
%days=("Mon" => "Monday",
           "Tue" => "Tuesday",
           "Wed" => undef,
          );



*******************
5.3. Reading from STDIN

***********************
The three filehandles STDIN, STDOUT, and STDERR

***chop and chomp ****

chop砍掉最后一个字符，不论是什么。chmop砍掉最后一个字符，只有当它是换行的时候。
1   print "Hello there, and what is your name? ";
2   $name = <STDIN>;
3   print "$name is a very high class name.\n";
4   chop($name);   # Removes the last character no matter what it is.
5   print "$name is a very high class name.\n\n";
6   chop($name);
7   print "$name has been chopped a little too much.\n";
8   print "What is your age?  ";
9   chomp($age=<STDIN>); # Removes the last character if
                         # it is the newline.
10  chomp($age);         # The last character is not removed
                         # unless a newline.
11  print "For $age, you look so young!\n";

(Output)
1   Hello there, and what is your name? Joe Smith
3   Joe Smith
    is a very high class name.
5   Joe Smith is a very high class name.

7   Joe Smit has been chopped a little too much.

8   What is your age？ 25
11  For 25, you look so young!

****************
read function

number_of_bytes = read(FILEHANDLE,buffer,how_many_bytes);
If reading from standard input, the filehandle is STDIN.  如果是从标准输入读入，那么文件句柄是STDIN

$number=read(STDIN, $favorite, 10);
The 10 characters read in are printed. The rest of the characters were discarded. 只有10个存进favorite 里的，后面的都被忽略了。


************
getc function

$restofit=<>;  # <> store　the input buff content.  <>里存缓存中的内容。 是什么就存什么。

print "Answer Y or N \n";
$answer=getc;
print "$answer.\n";   #通过这样的方式获得


**************
Assigning Input to an Array： 　从终端为数组赋值

@all = <STDIN>;
print "@all";
print "The number of elements in the array are: ",
           $#all + 1, ".\n";
print "The first element of the array is: $all[0]";


**************
5.4. Array Functions

**************
chop and chomp 和之前叙述类似， 不过，chop 返回的是它最后砍掉的变量，chomp返回的是它砍掉的变量的个数。

The chop function chops off the last character of a string and returns the chopped character, usually for removing the newline after input is assigned to a scalar variable. If a list is chopped, chop will remove the last letter of each string in the list.
The chomp function removes the last character of each element in a list if it ends with a newline and returns the number of newlines it removed.

一个栗子： 注意它们对应的输出。 看如何chop不论最后一个字符是什么，都无情删掉，最后保存最后一个删掉的字符，chomp只删掉换行，保存的是删掉的数量，而不是内容：
 @line=("red\n", "green", "orange");
 $chop_today=chop(@line);   # Chops the last character off each
1:print "chop_today is $chop_today.\n";
# string in the list
2: print "@line";
print "\n";
@line=( "red\n", "green\n", "orange");
$chomp_today=chomp(@line);  # Chomps the newline off each string in the list
3: print "@line";
print "\n";
4: print "chomp_today is $chomp_today.\n";

（output)
1: chop_today is e.
2: red gree orang
3: red green orange
4: chomp_today is 2.

********
5.4.2. The exists Function

The exists function returns true if an array index (or hash key) has been defined, and false if it has not. 数组索引存在也返回真，否则假。

@names=('Chris', 'Lynn' ,'Joanna');
print " Hello $names[0]\n", if exists $names[0];
print " Out of range\n", if not exists $names[4];
$exist_test_ture= exists $names[0];
$exist_test_faule= not exists $names[4];
print "exist_test_ture result is $exist_test_ture; exist_test_faule result is $exist_test_faule.\n";

(Output)
 Hello Chris
 Out of range
exist_test_ture result is 1; exist_test_faule result is 1. # 如果是 $exist_test_faule=  exists $names[4]; 返回值是空


********
5.4.3. The delete Function

The delete function allows you to remove a value from an element of an array but not the element itself. The value deleted is simply undefined. 删除掉指定的数组元素的值。该值成为未定义。数组大小不变。
1 @colors=("red","green","blue","yellow");
2  print "@colors\n";
3 delete $colors[1];  # green is removed
4 print "@colors\n";
5 print $colors[1],"\n";
6 $size=@colors;      # value is now undefined
7 print "The size of the array is $size.\n";

(Output)
2 red green blue yellow
4 red  blue yellow
7 The size of the array is 4.


**********
5.4.4. The grep Function
grep(EXPR,LIST)返回值是一个找到的结果的数组。如果是As a scalar value, the return value is the number of times the expression was true (i.e., the number of times the pattern was found).

@grep_test=("English","French","German","Chinese","Ten");
@grep_test_result=grep (/en/i,@grep_test);
$grep_test_result=grep (/en/i,@grep_test);
print "\@grep_test_result is @grep_test_result.\n";
print "\$grep_test_result is $grep_test_result.\n";
(Output)
@grep_test_result is English French Ten.
$grep_test_result is 3.


***********
5.4.5. The join Function
join(DELIMITER, LIST)  The join function joins the elements of an array into a single string and separates each element of the array with a given delimiter. 把一系列的数组元素连成一个串，用给定的分隔符分割。是split的反操作。

$you="You";
$are="are";
$fool="a fool";
$youareafool=join(" ",$you,$are,$fool);
@youareafool=join(" ",$you,$are,$fool);
@youareafool_1=join("-",$you,$are,$fool);
@youareafool_2=join("\n",$you,$are,$fool);
print "\$youareafool is $youareafool. \n";
print "\@youareafool is @youareafool. \n";
print "The second element of \@youareafool is $youareafool[1].\n ";
print "\@youareafool_1 is @youareafool_1. \n";
print "The first element of \@youareafool_1 is $youareafool_1[0].\n ";
print "\@youareafool_2 is @youareafool_2. \n";
print "The first element of \@youareafool_2 is $youareafool_2[0].\n ";
print "The Second element of \@youareafool_2 is $youareafool_2[1].\n ";

print " The size of \@youareafool_1 is ",$#youareafool_1 +1 ,"\n";
print " The size of \@youareafool_2 is ",$#youareafool_2 +1 ,"\n";

(Output)
$youareafool is You are a fool. 
@youareafool is You are a fool. 
The second element of @youareafool is .
 @youareafool_1 is You-are-a fool. 
The first element of @youareafool_1 is You-are-a fool.
 @youareafool_2 is You
are
a fool. 
The first element of @youareafool_2 is You
are
a fool.
 The Second element of @youareafool_2 is .

The size of @youareafool_1 is 1
 The size of @youareafool_2 is 1
#非常有意思的情况。 说明，join 的结果就是一个串。你可以把它存成一个数组，但结果是，这个数组只有一个元素，就是它的第一个元素.


数组的个数两种计算方法

@array_123=("Spring","Summer","Autumn","winter");
$count_123=@array_123;
print " the number of elements in the array is : $count_123 \n";
print " the number of elements in the array is :",  $#count_123 +1," \n";

***************
5.4.6. The map Function

就是把指定的列表数据，用指定的表达展现出来

map EXPR, LIST;
map {BLOCK} LIST;

一个栗子
print "\n *** map {BLOCK} list ****\n";
open(FH,"datebook.master") or die;
@array_132=<FH>;
print "The original array is: @array_132\n";
#有这两种实现方式
@array_after_map= map {split(":")} @array_132;
@array_20190325=map split(":"),@array_132;
# 此两种方法输出一样，都是
print "The mapped array: @array_after_map\n";
print "The mapped array at 20190325 is : @array_20190325\n";

***************
5.4.8. The pop Function
The pop function pops off the last element of an array and returns it. The array size is subsequently decreased by 1 
pop(ARRAY)
pop ARRAY

#两种实现形式都可以
$pop_162=pop(@array_161);
print "The string of pop for array_161 is: $pop_162 .\n";
print "The string of pop for20190325  is:" , pop @array_161, ".\n";


********
5.4.9. The push Function
The push function pushes values onto the end of an array, thereby increasing the length of the array.
push(ARRAY, LIST)

push(@names, "Jim", "Joseph", "Archie");


**********
5.4.10. The shift Function
The shift function shifts off and returns the first element of an array, decreasing the size of the array by one element. If ARRAY is omitted, then the ARGV array is shifted, and, if in a subroutine, the @_ array is shifted. 移除数组的第一个函数。 移除最后一个用的是pop函数

shift(ARRAY)
shift ARRAY
shift

$shift_1=shift @array_172;


*********************
5.4.11. The splice Function
The splice function removes and replaces elements in an array. 移除数组元素，（或者移除后也替换上新的元素）

splice(ARRAY, OFFSET, LENGTH, LIST)
splice(ARRAY, OFFSET, LENGTH)
splice(ARRAY, OFFSET)

OFFEST是开始位置（就是从第几个数组元素开始)，length 是要替换的长度（其实是数组元素的个数），LIST是The LIST consists of new elements that are to replace the old ones，其实就是把原数组里移除了的数据用这个list里的元素补充上。 见下面第二个栗子

#####
@discarded = splice(@colors, 2, 2);

#### 另一个栗子：
1   @colors=("red", "green", "purple", "blue", "brown");
2   print "The original array is @colors\n";
3   @lostcolors=splice(@colors, 2, 3, "yellow", "orange"); # 把这俩元素填补上移除的那三个。只补上了两个，当然。
4   print "The removed items are @lostcolors\n";
5   print "The spliced array is now @colors\n";

(Output)
2   The original array is red green purple blue brown 
4   The removed items are purple blue brown # offset is initially 0， so starting at offset 2 ( the third element) 从第三个元素开始，总共3个
5   The spliced array is now red green yellow orange # 注意这里的输出


*************

5.4.12. The split Function

The split function splits up a string (EXPR) by some delimiter (whitespace by default) and returns an array. 把数组元素用指定的分隔符，依据指定的表达式来分割。 分割成几个串可以用 limit来定义，比如本来可以分成5个，可就设定为2个，那最后一个就把从第二个分隔符开始的都包含进去了。
split("DELIMITER",EXPR,LIMIT)
split(/DELIMITER/,EXPR,LIMIT)
split(/DELIMITER/,EXPR)
split("DELIMITER",EXPR)
split(/DELIMITER/) ## 默认的知道哪个是当前数组的情况  while(<DATA>){ @line=split(":");....
split

DELIMITER是分割符，默认是空白分割（空格、　tab 或回车换行符）， eXPR是要分割的串，limit是the number of fields that can be split

#一个栗子
1   $line="a b c d e";
2   @letter=split(' ',$line);

#两个栗子：
        while(<DATA>){
     1       ($name,$phone,$address,$bd,$sal)=split(":");
     2       print "$name\t $phone\n" ;
         }
_ _DATA_ _
......

#三个栗子
1   $string= "Joe Blow:11/12/86:10 Main St.:Boston, MA:02530";
6   @str=split(":", $string, 2);
7   print $str[0],"\n";  # The first element of the array
8   print $str[1],"\n";  # The rest of the array because limit is 2
9   print $str[2],"\n";  # Nothing is printed
#因为指定为分割为两个（limit），所以第二个字段就把所有的剩下的都划在里面了。

********
5.4.13. The sort Function

sort(SUBROUTINE LIST)
sort(LIST)
sort SUBROUTINE LIST
sort LIST

The sort function doesn't change the orginial list.

If SUBROUTINE is specified, the first argument to sort is the name of the subroutine, followed by a list of values to be sorted. 如果指定了subroutine，那么第一个参数就是要怎么来排序的这个子函数，下一个参数才是要应用这个子函数的逻辑来排序的目标串

If the string "cmp" operator is used, the values in the list will be sorted alphabetically (ASCII sort),(cmp是字符比较） and if the <=> operator (called the "space ship" operator) is used, the values will be sorted numerically. （《=》是数学比较）

The subroutine returns an integer less than, equal to, or greater than 0. The values are passed to the subroutine by reference and are received by the special Perl variables $a and $b, not the normal @_ array. 这个子函数会根据比较结果返回01-1一类的值，用来传递回$a $b 所以这俩是有特殊意义的，别随便定义修改它们。
(See subroutines in Chapter 11 for further discussion.) Do not try to modify $a or $b, as they represent the values that are being sorted.

#栗子：ASCII and Numeric Sort Using Subroutine
1 @list=("dog","cat", "bird","snake" );
  print "Original list: @list\n";
   # ASCII sort using a subroutine
2  sub asc_sort{
3          $a cmp $b;  # Sort ascending order。如果要降序，就是$b cmp $a
   }
4  @sorted_list=sort asc_sort(@list);
   print "Ascii sort: @sorted_list\n";

   # Numeric sort using subroutine
5  sub numeric_sort {
       $a <=> $b ;
   }  ######## $a and $b are compared numerically，是升序的，If $a and $b are reversed (e.g., $b <=> $a), then the sort is done in numeric descending order

6  @number_sort=sort numeric_sort 10, 0, 5, 9.5, 10, 1000;
   print "Numeric sort: @number_sort.\n";


####Using an Inline Function to Sort a Numeric List 把小子函数直接写进一个命令里：
1   @sorted_numbers= sort {$a <=> $b} (3,4,1,2);
2   print "The sorted numbers are: @sorted_numbers", ".\n";
####
@array=sort {$a cmp $b} Anna,Holy,Chris,Emma;   字符如此。


*********
5.4.14. The reverse Function
The reverse function reverses the elements in an array

@reversed=reverse(@names),"\n";

********
5.4.15. The unshift Function
The unshift function prepends LIST to the front of the array. 在一个数组前插入元素，所以插入的元素会在数组的开头 在结尾追加元素是用push函数。

1   @names=("Jody", "Bert", "Tom") ;
2   unshift(@names, "Liz", "Daniel");
3   print "@names\n";

(Output)
3   Liz Daniel Jody Bert Tom





************

5.5. Hash (Associative Array) Functions

************
5.5.1. The keys Function
The keys function returns, in random order, an array whose elements are the keys of a hash 随机的返回键值，组成数组。

2   foreach $key ( keys(%weekday) ){print "$key ";}。#随机打印。
    print "\n";
3   foreach $key ( sort keys(%weekday) ){print $key ;}
    print "\n";

**********
5.5.2. The values Function
The values function returns, in random order, an array consisting of all the values of a hash. 随机返回内容，组成数组

foreach $value ( values(%weekday)){print "$value";}

********
5.5.3. The each Function
The each function returns, in random order, a two-element array whose elements are the key and the corresponding value of a hash.

while(($key,$value)=each(%weekday)){
3      print "$key = $value\n";



**********
5.5.4. Sorting a Hash

按照健字母顺序排序很容易，用内嵌的sort函数就可以完成，可如果按照内容（values）排序，就有点麻烦了，需要用子函数来排。方法和数组部分讲的sort方法差不多。规则和禁戒也相同。

*******Sort Hash by Keys in Ascending Order

To perform an Ascii or alphabetic sort on the keys in a hash is relatively easy. The sort() function is given a list of keys and returns them sorted in ascending order. A foreach loop is used to loop through the hash one key at a time。 

foreach $value_289(reverse sort (%h_264))
{
    print "$value_289 , $h_264{$value_289} \n";
}


*****Sort Hash by Keys in Reverse Order

foreach $keys ( reverse sort keys %h_264)
{
    print "--reverse----$keys-----$h_264{$keys}\n";
}

*********Sort Hash by Keys Numerically

# numerically
foreach $keys ( sort {$b <=> $a} keys %h_264)  {print "-numerically-----$keys-----$h_264{$keys}\n";}
#alphabetically
foreach $keys ( sort {$a cmp $b} keys %h_264)  {print "-alphabetically-----$keys-----$h_264{$keys}\n";}

**********Numerically Sort a Hash by Values in Ascending Order
#要用一个子函数，把哈希的values进行排序，方法是通过键值，sub hash_sort{$hash{$a} <=> $hash{$b};} 可以直接内嵌，就成了下面这样的。不要用values直接来做，因为那样只有values， 你怎么得到keys啊，没有keys ，哈希也不好使了啊
foreach $keys(sort { $h_305{$a} <=> $h_305{$b} } ( keys (%h_305)))
{
    print "sort by value numerically: $keys---$h_305{$keys}.\n";
}

**********Numerically Sort a Hash by Values in Descending Order

sub hash_desc_sub
{
    $h_305{$b} <=> $h_305{$a};
}
foreach $keys( sort hash_desc_sub keys %h_305 )
{
    print "sort by value numerically descending: $keys---$h_305{$keys}.\n";
}




*************
5.5.5. The delete Function

The delete function deletes a value from a hash. The deleted value is returned if successful 返回值就是那个被删除掉的value

  $layoff=delete $employees{"Janitor"};
    print "We had to let $layoff go.\n";
#然后剩下：
    while(($key, $value)=each(%employees)){
       print "$key: $value\n";
    }

*************
5.5.6. The exists Function
The exists function returns true if a hash key (or array index) has been defined, and false if not.

print " exist Friday-> $h_305{Friday} \n" if exists $h_305{Friday};



************************
************************

Chapter 6. Where's the Operator?

***********************
*************************


*******
6.3.1. Assignment Operators

$var += 3;
print "\$var += 3 is $var \n";

$var -= 1;
print "\$var -=  1 is $var \n";

$name .="ny";
print "the full of \$name is  $name \n";

$line x= 10;
print "$line\n";

printf "\$var is %.2f\n",$var=4.2 + 2.3 ;

(Output)

$var += 3 is 3 
$var -=  1 is 2 
the full of $name is  Danny 
**********
$var is 6.50


********
6.3.2. Relational Operators

Relational operators are used to compare operands. The result of the comparison is either true or false.[3] Perl has two classes of relational operators: one set that compares numbers and another that compares strings.  比较操作数，返回真或假，有两套，一套比较字符串，另一套比较数字。

Relational Operators and Numeric Values
Operator	Example	Meaning
>		$x > $y   $x is greater than $y
>=		$x >= $y	$x is greater than or equal to $y
<		$x < $y	$x is less than $y
<=		$x <= $y	$x is less than or equal to $y


Relational Operators and String Values
Operator	Example			Meaning
gt		$str1 gt $str2		$str1 is greater than $str2
ge		$str1 ge $str2		$str1 is greater than or equal to $str2
lt		$str1 lt $str2		$str1 is less than $str2
le		$str1 le $str2		$str1 is less than or equal to $str2


Equality Operators and Numeric Values
Operator	Example			Meaning
==		$num1 == $num2		$num1 is equal to $num2
!=		$num1 != $num2		$num1 is not equal to $num2
<=>		$num1 <=> $num2		$num1 is compared to $num2 with a signed return; 1 if $num1 is greater than $num2, 0 if $num1 is equal to $num2, and -1 if $num1 is less than $num2

Equality Operators and String Values
Operator	Example			Meaning
eq		$str1 eq $str2		$str1 is equal to $str2
ne		$str1 ne $str2		$str1 is not equal to $str2
cmp		$str1 cmp $str2		$str1 is compared to $str2, with a signed return


#### Don't use == when you should use eq!
1   $x = "yes";
    $y = "no";
    print "\nIs yes equal to no? If so, say 1; if not say 'null'.\n";
2   print "The result is: ",$x == $y,"\n";    # Should be $x eq $y

(Output)
1   Is yes equal to no? If so, say 1; if not say 'null'.
2   The result is: 1. # 其实应该返回0才对，这样 yes居然等于no了。所以对串比较，千万别用==那是比较数字的。



##############
6.3.4. Logical Operators (Short-Circuit Operators)

Operator	Alternative Form	Example		Meaning
&&			and			$x && $y		If $x is true, evaluate $y and return $y
 	 					$x and $y		If $x is false, evaluate $x and return $x
||			or			$x || $y		If $x is true, evaluate $x and return $x
 	 					$x or $y		If $x is false, evaluate $y and return $y
 			xor			$x xor $y		True if $x or $y is true, but not both
!			not			! $x			Not $x; true if $x is not true
 	 					not $x	 

######Arithmetic Operators
Operator	Example	Meaning
+		$x + $y	Addition
-		$x - $y	Subtraction
*		$x * $y	Multiplication
/		$x / $y	Division
%		$x % $y	Modulus
**		$x ** $y	Exponentiation


######6.3.7. Autoincrement and Autodecrement Operators

Example	Description	Equivalence
++$x		Preincrement	$x = $x + 1
$x++		Postincrement	$x = $x + 1
--$x		Predecrement	$x = $x - 1
$x--		Postdecrement	$x = $x - 1


Autoincrement and Autodecrement Operators and Assignment
Example						Description	 							Equivalence			Result
If $y is 0 and $x is 0: $y = $x++;	Assign the value of $x to $y, then increment $x	$y = $x; $x = $x + 1;	$y is 0 $x is 1
If $y is 0 and $x is 0: $y = ++$x;	Increment $x, then assign $x to $y				$x = $x + 1; $y = $x;	$x is 1 $y is 1
If $y is 0 and $x is 0: $y = $x--;	Assign the value of $x to $y, then decrement $x	$y = $x; $x = $x - 1;	$y is 0 $x is -1
If $y is 0 and $x is 0: $y = --$x;	Decrement $x, then assign $x to $y				$x = $x - 1; $y = $x;	$x is -1 $y is-1


######6.3.8. Bitwise Logical Operators


 Bitwise Logical Operators

Operator	Example	Meaning
&		$x & $y	Bitwise and
|		$x | $y	Bitwise or
^		$x ^ $y	Bitwise exclusive or
<<		$x << 1	Bitwise left shift, integer multiply by two
>>		$x >> 1	Bitwise right shift, integer divide by two


Resulting Values of Bitwise Operators

$x	$y	$x & $y	$x | $y	$x ^ $y
0	0		0		0	0
0	1		0		1	1
1	0		0		1	1
1	1		1		1	0

***************
6.3.9. Conditional Operators
conditional expression ? expression : expression
$x ? $y : $z

**************
6.3.10. Range Operator
The range operator is used in both scalar and array context. In a scalar context, the value returned is a Boolean, 1 or 0. In an array context, it returns a list of items starting on the left side of the operator and counting by ones until the value on the right-hand side is reached.标量和数组都可以用。标量应用中，返回布尔值，0或1.数组中，返回范围内的值称为一个列表。


***********
6.3.11. Special String Operators and Functions

String Operations
Example					Meaning
$str1 . $str2				Concatenate strings $str1 and $str2
$str1 x $num				Repeat $str1, $num times
substr($str1, $offset, $len)	Substring of $str1 at $offset for $len bytes
index($str1, $str2)			Byte offset of string $str2 in string $str1
length(EXPR)				Returns the length in characters of expression, EXPR
rindex($str, $substr, POSITION)		Returns the position of the last occurrence of $substr in $str.
							If POSITION is specified, start looking there.
							If POSITION is not specified, start at the end of the string.
chr(NUMBER)				Returns the character represented by that NUMBER in the ASCII character set. For example, chr(65) 							is the letter A.
lc($str)					Returns a lowercase string
uc($str)					Returns an uppercase string


*********
6.3.12. Arithmetic Functions

Built-in Perl Arithmetic Functions
atan2(Y,X)					Returns the arctangent of Y/X in the range â€“PI to PI.
cos(EXPR) cos EXPR			Returns the cosine of EXPR (expressed in radians). If EXPR is omitted, takes cosine of $_.
exp(EXPR) exp EXPR			Returns e to the power of EXPR. If EXPR is omitted, gives exp($_).
int(EXPR) int EXPR			Returns the integer portion of EXPR. If EXPR is omitted, uses $_.
log(EXPR) log EXPR			Returns logarithm (base e) of EXPR. If EXPR is omitted, returns log of $_.
rand(EXPR) rand EXPR rand			Returns a random fractional number between 0 and the value of EXPR. (EXPR should be positive.) 							If EXPR is omitted, returns a value between 0 and 1. See also srand().
sin(EXPR) sin EXPR			Returns the sine of EXPR (expressed in radians). If EXPR is omitted, returns sine of $_.
sqrt(EXPR) sqrt EXPR			Return the square root of EXPR. If EXPR is omitted, returns square root of $_.
srand(EXPR) srand EXPR		Sets the random number seed for the rand operator. If EXPR is omitted, does srand(time).


*******Generating Random Numbers

As described in an article by Ian Goldberg and David Wagner concerning Web security, truly random numbers can be found only in nature, such as the rate of decay of a radioactive element.

The srand function sets the random number seed for the rand function but is no longer required if you are using a version of Perl greater than 5.004. A seed is a random number itself that is fed to the random number generator as the starting number from which new random numbers are produced.

while ($num)
{
    $rand_164=int(rand($num)) + 1;
    print "The rand nuber is $rand_164 \n";
    $rand_167=rand + 1;
    print "The rand number of nake rand is $rand_167 \n";
    sleep 3;
    $num--;
}


***************************

Chapter 7. If Only, Unconditionally, Forever

***************************


Foreach
The foreach loop iterates over each element in the parenthesized list, an array, assigning each element of the array to a scalar variable, one after the other, until the end of the list.

The VARIABLE is local to the foreach block. It will regain its former value when the loop is exited. Any changes made when assigning values to VARIABLE will, in turn, affect the individual elements of the array. If VARIABLE is not present, the $_ special scalar variable is implicitly used.

foreach VARIABLE (ARRAY)
{BLOCK}

*******
7.2.5. Loop Control


********
7.2.6. The switch Statement

switch (expression) {
  case value1 :
     /* statements */
     break;
  case value2 :
     /* statements */
     break;
  case value3 :
     /* statements */
     break;
  default:
     /* statements */
     break;
}



****************
******************

Chapter 8. Regular Expressionsâ€”Pattern Matching

*******************
******************


**********
8.2.2. The DATA Filehandle
In the following examples, the special filehandle called DATA is used as an expression in a while loop. This allows us to directly get the data from the same script that is testing it, rather than reading input from a separate text file. (You will learn all about filehandles in Chapter 10, "Getting a Handle on Files.") 

while(<DATA>){.   # ($_=<DATA>) and ($inputline=<DATA>) 也都可以
    Do something with the data here
}
_ _DATA_ _
    The actual data is stored here



*******
The unless Modifier

Expression2 unless Expression1;

$x=5;


   print $x unless $x == 6;


*********8.2.3. Looping Modifiers



1   $x=1;
2   print $x++,"\n" while $x != 5;

1   $x=1;
2   print $x++,"\n" until $x == 5;

1   @alpha=(a .. z, "\n");
2   print foreach @alpha;


***************
8.3. Regular Expression Operators
************

******8.3.1. The m Operator and Matching
用来指定分隔符，如果是// 可以不用m.，//是默认的分隔符
/Regular Expression/     default delimiter
m#Regular Expression#    optional delimiters
m{regular expression}    pair of delimiters

Matching Modifiers
Modifier	Meaning
i		Turn off case sensitivity.
m		Treat a string as multiple lines.
o		Compile pattern only once. Used to optimize the search.
s		Treat string as a single line when a newline is embedded.
x		Permit comments in a regular expression and ignore whitespace.
g		Match globally; i.e., find all occurrences. Return a list if used with an array context, or true or false if a scalar context.

**********
The g Modifier Global Match

1   $_ = "I lost my gloves in the clover, Love.";
2   @list=/love/g;

*******The i Modifier Case Insensitivity

1   $_ = "I lost my gloves in the clover, Love.";
2   @list=/love/gi;
3   print "@list.\n";


*******Special Scalars for Saving Patterns
The $ & special scalar is assigned the string that was matched in the last successful search. &` saves what was found preceding the pattern that was matched, and &' saves what was found after the pattern that was matched.
$&存最后匹配上的内容，&` 存之前的，&'存之后的


*******The x Modifier The Expressive Modifier
The x modifier allows you to place comments within the regular expression and add whitespace characters (spaces, tabs, newlines) for clarity without having those characters interpreted as part of the regular expression; in other words, you can express your intentions within the regular expression.

$_= "We are the hope of the world";
print "Result is $&.\n" if /the    #looking for the patterns
/x;
这里的空格，注释都不影响结果


***********8.3.2. The s Operator and Substitution
The s operator is used for substitutions.

s/old/new/;
s/old/new/i;
s/old/new/g;
s+old+new+g;
s(old)/new/;   s[old]{new};
s/old/expression to be evaluated/e;
s/old/new/ige;
s/old/new/x;

Substitution Modifiers
Modifier	Meaning
e		Evaluate the replacement side as an expression.
i		Turn off case sensitivity.
m		Treat a string as multiple lines.[a]
o		Compile pattern only once. Used to optimize the search.
s		Treat string as single line when newline is embedded.
x		Allow whitespace and comments within the regular expression.
g		Replace globally; i.e., find all occurrences.


The e Modifier Evaluating an Expression
 while(<DATA>){
2       s/6/6 * 7.3/eg;       # Substitute 6 with product of 6 * 7.3
3       print; # 结果会是用6 * 7.3的结果代替6

#又一个栗子
s[knock]{"knock, " x 2 . "knocking"}ie;
#s/knock/"knock, " x 2 . "knocking"/ie;
print "He is $_\n";
（output)
He is knock, knock, knocking at heaven's door.


**********
8.3.3. Pattern Binding Operators	

Table 8.3. Pattern Matching Operators
Example				Meaning
$name =~ /John/			True if $name contains pattern. Returns 1 for true, null for false.
$name !~ /John/			True if $name does not contain pattern.
$name =~ s/John/Sam/		Replace first occurrence of John with Sam.
$name =~ s/John/Sam/g	Replace all occurrences of John with Sam.
$name =~ tr/a-z/A-Z/		Translate all lowercase letters to uppercase.
$name =~ /$pal/			A variable can be used in the search string.


#yige lixi:

$name="either IELTS or BEC is my tagert";
print $name ,"\n" if $name =~ tr/a-z/A-Z/;

(Output)
EITHER IELTS OR BEC IS MY TAGERT

# another good lixi:

1   while(<DATA>){
2       @line = split(":", $_);
3       print $line[0],"\n" if $line[1] =~ /408-/
                              # Using the pattern matching operator
    }
4   __DATA__.  #注意这里两个下滑线之间没空格
    Igor Chevsky:408-567-4444:3456 Mary Way

(Output)
Igor Chevsky

上面栗子也可以这样：
      ($name, $phone, $address) = split(":", $_);
3           print $name if $phone =~ /408-/



**************************
*************************

Chapter 9 正则疯狂匹配

************************
*************************

Regular expression metacharacters are characters that do not represent themselves. They are endowed with special powers to allow you to control the search pattern in some way (e.g., find the pattern only at the beginning of line or at the end of the line or only if it starts with an upper- or lowercase letter). Metacharacters lose their special meaning if preceded with a backslash (\). For example, the dot metacharacter represents any single character but when preceded with a backslash is just a dot or period.




Metacharacter	What It Matches
######Character Class: Single Characters and Digits

.			Matches any character except a newline
[a-z0-9]		Matches any single character in set
[^a-z0-9]		Matches any single character not in set
\d			Matches one digit
\D			Matches a nondigit, same as [^0-9]
\w			Matches an alphanumeric (word) character
\W			Matches a nonalphanumeric (nonword) character


#######Character Class: Whitespace Characters
\s			Matches a whitespace character, such as spaces, tabs, and newlines
\S			Matches nonwhitespace character
\n			Matches a newline
\r			Matches a return
\t			Matches a tab
\f			Matches a form feed
\b			Matches a backspace
\0			Matches a null character



######Character Class: Anchored Characters
\b			Matches a word boundary (when not inside [ ])
\B			Matches a nonword boundary
^			Matches to beginning of line
$			Matches to end of line
\A			Matches the beginning of the string only
\Z			Matches the end of the string or line
\z			Matches the end of string only
\G			Matches where previous m//g left off


########Character Class: Repeated Characters
x?			Matches 0 or 1 x
x*			Matches 0 or more occurrences of x
x+			Matches 1 or more occurrences of x
(xyz)+		Matches 1 or more patterns of xyz
x{m,n}		Matches at least m occurrences of x and no more than n occurrences of x


########Character Class: Alternative Characters
was|were|will	Matches one of was, were, or will


########Character Class: Remembered Characters
(string)		Used for backreferencing (see Examples 9.38 and 9.39)
\1 or $1		Matches first set of parentheses[a]
\2 or $2		Matches second set of parentheses
\3 or $3		Matches third set of parentheses



#########Character Class: Miscellaneous Characters
\12			Matches that octal value, up to \377
\x811			Matches that hex value
\cX			Matches that control character; e.g., \cC is <Ctrl>-C and \cV is <Ctrl>-V
\e			Matches the ASCII ESC character, not backslash
\E			Marks the end of changing case with \U, \L, or \Q
\l			Lowercase the next character only
\L			Lowercase characters until the end of the string or until \E
\N			Matches that named character; e.g., \N{greek:Beta}
\p{PROPERTY}	Matches any character with the named property; e.g., \p{IsAlpha}/
\P{PROPERTY}	Matches any character without the named property
\Q			Quote metacharacters until \E
\u			Titlecase next character only
\U			Uppercase until \E
\x{NUMBER}		Matches Unicode NUMBER given in hexadecimal
\X			Matches Unicode "combining character sequence" string
\[			Matches that metacharacter
\\			Matches a backslash



#####The Dot Metacharacter
The dot (.) metacharacter matches any single character with the exception of the newline character. 不能匹配换行

$_="Sing a song of sixpence\nA pocket full of rye.\n";
# print if /pence.A/s ;

print $& if /pence.A/s ;
print "\n";
print if s/sixpence.A/twopence, a/s;   # 前一个s是替换模式开关，后一个是令dot识别换行开关

(Output)
pence
A
Sing a song of twopence, a pocket full of rye.


########The s Modifier: The Dot Metacharacter and the Newline
The s modifier treats the line with embedded newlines as a single line, rather than a group of multiple lines, and allows the dot metacharacter to treat the newline character the same as any other character it might match. The s modifier can be used with both the m (match) and the s (substitution) operators.
 s 可以把换行\n也当作一个字符来处理，这样，dot(.)就可以匹配换行了。 可以和 m 匹配和s替换结合着来使用。
注意，这个转意s在后，替换s在前。见4.

1   $_="Sing a song of sixpence\nA pocket full of rye.\n";
2   print $& if /pence./s;
3   print $& if /rye\../s;
4   print if s/sixpence.A/twopence, a/s;

(Output)
2   pence
3   rye.
4   Sing a song of twopence, a pocket full of rye.


#########Metacharacters that Turn off Greediness
By placing a question mark after a greedy quantifier, the greed is turned off, and the search ends after the first match 
rather than the last one.
在匹配模式后加一个？　就可以关闭贪婪模式，

1   $_="abcdefghijklmnopqrstuvwxyz";
2   s/[a-z]+/XXX/;
3   print $_, "\n";

4   $_="abcdefghijklmnopqrstuvwxyz";
5   s/[a-z]+?/XXX/;
6   print $_, "\n";

(Output)
3   XXX
6   XXXbcdefghijklmnopqrstuvwxyz

########Turning Off Greediness

x??		Matches 0 or 1 occurrences of x
(xyz)??		Matches 0 or 1 occurrences of pattern xyz
x*?		Matches 0 or more occurrences of x
(xyz)*?		Matches 0 or more occurrences of pattern xyz
x+?		Matches 1 or more occurrences of x
(xyz)+?		Matches 1 or more occurrences of pattern xyz
x{m,n}?		Matches at least m occurrences of x and no more than n occurrences of x
x{m}?		Matches at least m occurrences of x
x{m,}?		Matches at least m times


##########Table 9.7. Anchors (Assertions)

^	Matches to beginning of line or beginning of string
$	Matches to end of line or end of a string
\A	Matches the beginning of the string only
\Z	Matches the end of the string or line
\z	Matches the end of string only
\G	Matches where previous m//g left off
\b	Matches a word boundary (when not inside [ ])
\B	Matches a nonword boundary


1   while(<DATA>){
2       print if /\bJon/;
    }
    _ _DATA_ _
    Steve Blenheim 1.10
    Betty Boop .5
    Igor Chevsky 555.100
    Norma Cord 4.01
    Jonathan DeLoach .501
    Karen Evich 601

(Output)
Jonathan DeLoach .501
******The expression reads: Find a word beginning with the pattern Jon

所以下面这个没有输出：Find a word beginning and ending with Jon. Nothing is found.
1   while(<DATA>){
2       print if /\bJon\b/;
    }


########The m Modifier
用了m,可以把^ $ 这两个首位匹配 覆盖到换行\n, 否则，遇到换行，首位匹配就都不继续向下识别了，不过　m 对　/A和/z都是不起作用的！只对$^管用
A string containing newlines will be treated as multiple lines. If the regular expression is anchored with the ^ metacharacter,
 and that pattern is found at the beginning of any one of the multiple lines, the match is successful.

perl -e ' $_="Today is history.\nTomorrow will never be here.\n";print if /^Tomorrow/;'
----没结果
perl -e ' $_="Today is history.\nTomorrow will never be here.\n";print if /^Tomorrow/m;'
Today is history.
Tomorrow will never be here.
可以匹配出来


#########Alternation

print if /Steve|Betty|Jon/;


##########Grouping or Clustering（）
If the regular expression pattern is enclosed in parentheses, a subpattern is created
扩在括号里，就成为一个集群，可以最当做一个小单独个体来对待。 　（）

1   $_=qq/The baby says, "Mama, Mama, I can say Papa!"\n/;
2   print if s/(ma|pa)+/goo/gi;

(Output)
The baby says, "goo, goo, I can say goo!"
******:The expression reads: Find one or more occurrences of the pattern ma or pa and replace that with goo.


1   while(<DATA>){
2       print if /\s(12){3}$/;  # Print lines matching exactly 3
                                # consecutive occurrences of 12 at
                                # the end of the line
    }
    _ _DATA_ _
    Steve Blenheim  121212
    Betty Boop      123
    Igor Chevsky    123444123
    Norma Cord      51235
    Jonathan DeLoach123456
    Karen Evich     121212456

(Output)
Steve Blenheim 121212


2       # print if /^Steve|Boop/;It would print any line that begins with Steve and any line containing the pattern Boop.
                                 / 会打印出以Steve开头的行，以及包含　Boop的行，头标并不会作用到 Boop的。
3         print if /^(Steve|Boop)/; /这个才会把都是两个开头的行打出来。



#######Remembering or Capturing
把一个模式括在括号里，除了可以当作一个小独立个体外，另一个用途是，它们都被编号存在内存里了。想取出来用十分方便。
If the regular expression pattern is enclosed in parentheses, a subpattern is created. 
The subpattern is saved in special numbered scalar variables, starting with $1, then $2, and so on.


s/([Jj]on)/$1lathan/; /把　Jon或jon 替换为　Jonlathan or Jonathan 了。 

---
print if s/(Steve) (Fraze)/$2,$1/.  /把Steve Fraze替换为Fraze,Steve


1   while(<DATA>){
2       s/([A-Z][a-z]+)\s([A-Z][a-z]+)/$2, $1/;
                                       # Reverse first and last names
3       print;
    }
    _ _DATA_ _
    Steve Blenheim
    Betty Boop
    Igor Chevsky
    Norma Cord
    Jon DeLoach
    Karen Evich

  # 这段会把一行的名和姓点颠倒输出。 不过在第五个会遇到麻烦。输出是De Jon. 解决方法：  s/([A-Z][a-z]+)\s([A-Z][A-Za-z]+)/$2, $1/;

# The following works the same:
   s/(\w+)\s(\w+)/$2,$1/;

#and:
2       ($first, $last)=/(\w+) (\w+)/;   # Could be: (\S+) (\S+)/
3       print "$last, $first\n";


#

1   $string="ABCdefghiCxyzwerC YOU!";
2   $string=~s/.*C/HEY/;
3   print "$string", "\n";
#/.*C/, reads: Find the largest pattern that contains any number of characters ending in C. This search is greedy.
 It will search from left to right until it reaches the last C. 

(Output)
HEY YOU!

######## a good example of ? Turn off greedy modes
1   $fruit="apples pears peaches plums";
2   $fruit =~ /(.*)\s(.*)\s(.*)/;
3   print "$1\n";
4   print "$2\n";
5   print "$3\n";
    print "-" x 30, "\n";
6   $fruit="apples pears peaches plums";
7   $fruit =~ /(.*?)\s(.*?)\s(.*?)\s/; # Turn off greedy quantifier
8   print "$1\n";
9   print "$2\n";
10  print "$3\n";

(Output)
3   apples pears
4   peaches
5   plums
    ------------------------------
8   apples
9   pears
10  peaches

The string is divided into three remembered substrings, each substring enclosed within parentheses. The .* metacharacter sequence reads zero or more of any character. The * always matches for the largest possible pattern. The largest possible pattern would be the whole string. However, there are two whitespaces outside of the parentheses that must also be matched in the string. What is the largest possible pattern that can be saved in $1 and still leave two spaces in the string? The answer is apples pears.
第一个匹配，.*会匹配最大可能。括号把他们分成三部分，留下剩下两部分，第一个就会存下apples pears.
This time, a question mark follows the greedy quantifier (*). This means that the pattern saved will be the minimal, rather than the maximal, number of characters found. apples will be the minimal numbers of characters stored in $1, pears the minimal number in $2, and peaches the minimal number of characters in $3. The \s is required or the minimal amount of characters would be zero, since the * means zero or more of the preceding character.
第二个匹配，?关闭了贪婪模式，所以.* 会匹配最小的符合条件。那就是只有apples. 最后要加一个\s  否则，最小的匹配会是空，而不会是peaches.


########turn off capturing  关闭分组存储
如果只想用括号来分组，并不打算存在$1 $2等里，那么可以用　？：来关闭存储的方式。只保留分组的功能
When the only purpose is to use the parentheses for grouping, and you are not interested in saving the subpatterns in $1, $2, or $3, the special ?: metacharacter can be used to suppress the capturing of the subpattern.

#:
$_="Tom Savage and Dan Savage are brothers.\n";
print if /(?:T[a-z]*)/;
print "$1\n";

OUTPUT:
Tom Savage and Dan Savage are brothers.
Use of uninitialized value $1 in concatenation (.) or string at ./9_2_re.pl line 66.


################Metacharacters that Look Ahead and Behind

/PATTERN(?=pattern)/	Positive look ahead
/PATTERN(?!pattern)/	Negative look ahead
(?<=pattern)/PATTERN/	Positive look behind
(?<!pattern)/PATTERN/	Negative look behind


#
$string="I love chocolate cake and chocolate ice cream.";
$string =~ s/chocolate(?= ice)/vanilla/;
print "$string \n";

OUTPUT
I love chocolate cake and vanilla ice cream. （注意只有chocolate被替换，后面的ice只是做为查找限定的条件，并不会被替换！！！！！！！！！）

# a negative ahead :
print if/^\w+\s(?![BC])/;    一个词，一个空格，然后不能是 B或C开头的。

# A positive look behind

1   $string="I love chocolate cake, chocolate milk,
             and chocolate ice cream.";
2   $string =~ s/(?<= chocolate) milk/ candy bars/;
OUTPUT：
 I love chocolate cake, chocolate candy bars, and chocolate ice cream.
如果milk	前是 chocolate，milk，注意是milk，而不是chocolate milk 将被替换为candy bars！！！！！！！！

### negative look behind
 print if /(?<!Betty) B[a-z]*/;



##########

9.1.4. The tr or y Function


tr Modifiers
Modifier	Meaning
d		Delete characters
c		Complement the search list
s		Squeeze out multiple characters to single character



Format
tr/search/replacement/
tr/search/replacement/d
tr/search/replacement/c
tr/search/replacement/s
y/search/replacement/      (same as tr; uses same modifiers)


##
 tr/a-z/A-Z/;print;

### c:

  while(<DATA>){
       tr/0-9/*/c; print;
}
__DATA__
Steve Blenheim 101
Betty Boop  202

OUTPUY:
***************101*
************202*

把所有不在串里的字符，都替换成了目标字符，也就是所有不是数字的，都替换成*了。 （多么诡异的功能！！！）
The c (complement) option complements the search string; that is, it translates each character not listed in this string to its corresponding character in the replacement string.


###The tr Squeeze Option
把相同的符号压缩成只剩下一个
while (<DATA>){
        tr/:/:/s;
        print;
    {
    _ _DATA_ _
    1:::Steve Blenheim
    2::Betty Boop
    3:Igor Chevsky
    4:Norma Cord
    5:::::Jon DeLoach
    6:::Karen Evich

(Output)
1:Steve Blenheim
2:Betty Boop
3:Igor Chevsky
4:Norma Cord
5:Jon DeLoach
6:Karen Evich
其实是替换成只有一个：。如果不用：，就会替成那个新的，比如-
非常好用！！！！！！！

The end of Chapter 9



###################################
#######  Chapter 10.   ###########
##################################



### 10.1.2 Open for reading
1   open(FILEHANDLE, "FILENAME");
2   open(FILEHANDLE, "<FILENAME");
2   open(FILEHANDLE);
3   open FILEHANDLE;

#### Closing the filehandle
close (FILEHANDLE);
close FILEHANDLE;

If you don't explicitly close the file, when you reopen it this way, the line counter variable, $., will not be reset. 
Closing a pipe causes the process to wait until the pipe is complete and reports the status in the $! variable
不及时关闭句柄问题多多哦

####### die function 

the die function is used if a call to the open function fails. If Perl cannot open the file, the die function is used 
to exit the Perl script and print a message to STDERR, usually the screen.
如果打开文件失败，die函数会推出perl程序，并将出错信息写入　STDERR

a special variable $! to hold the value of the system error that occurs when you are unable to successfully open a file 
or execute a system utility.
$!会用来存储出错的信息

open (FILE1,"hellohaha") || die " I cannot open the file ." ;
OUTPUT: I cannot open the file . at ./10_file.pl line 72, <DB> line 6.

open (FILE1,"hellohaha") || die " I cannot open the file .\n" ;
OUTPUT: I cannot open the file .

open (FILE1,"hellohaha") || die " I cannot open the file . $!\n" ;
OUTPUT: I cannot open the file . No such file or directory

Note: The \n suppresses any further output from the die function. All of die's output is sent to STDERR 
after the program exits.
Omitting the \n causes the die function to append a string to the output, indicating the line number 
in the script where the system error occurred.


\n会只把die的内容显示，并存到STDERR句柄。如果不加，会把错误发生的具体位置也展示出来
而$!里，存着具体的出错原因。他们会一起被写入　STDERR



#########Reading from the Filehandle

1   open(FILE, "datebook") || die "Can't open datebook: $!\n";
2   while(<FILE>) {
3       print if /Sir Lancelot/;
4   }
5   close(FILE);

--
while($line = <FILE>) 
---
@lines = <FILE>;

--	

#########Open for writing 

Format
1   open(FILEHANDLE, ">FILENAME)";

1.  $file="/home/jody/ellie/perl/newfile"; 
2   open(HANDOUT, ">$file") || die "Can't open newfile: $!\n";
3   print HANDOUT "hello world.\n";
4   print HANDOUT "hello world again.\n";

###########Open for appending 
open(FILEHANDLE, ">> FILENAME");

########### select ： 改变当前句柄的函数，很好用的函数！！！

用select 函数，把当前句柄设置为默认句柄，所有输入输出都会操作在这个句柄对应的文件中。它的返回值为前一个句柄。

改变当前句柄，就表示，可以把要操作的输出的内容，打印到另一个文件里，只要把另一个文件的句柄设置为当前句柄。


open (FILEOUT,">newfile")  || die "Can't open newfile: $!\n"; 
select(FILEOUT);# 以前的默认句柄是STDOUT，现在变成了　FILEOUT

如果这样写 $oldfile=select(FILEOUT）, 那么，当前句柄仍被改为　FILEOUT，　但$filefile里存的变量是前一个句柄，也就是STDOUT，即屏幕。


(The Script)
    #! /usr/bin/perl
1   open (FILEOUT,">newfile")  || die "Can't open newfile: $!\n";
2   select(FILEOUT);      # Select the new filehandle for output
3   open (DB, "<datebook") || die "Can't open datebook: $!\n";
    while(<DB>) {
4      print ;            # Output goes to FILEOUT, i.e., newfile 文件内容会被打入进当前的句柄　FILEOUT。
    }
5   select(STDOUT);       # Send output back to the screen #再把当前句柄设置回来，到屏幕。
    print "Good-bye.\n";  # Output goes to the screen

# 



#########File Locking with flock：文件锁操作。
To prevent two programs from writing to a file at the same time, you can lock the file so you have exclusive access to it and then unlock it when you're finished using it. The flock function takes two arguments: a filehandle and a file locking operation
把正在操作的文件加保护锁，防止在自己写操作的时候，也有别人操作它而引起混乱

 File Locking Operations
Name	Operation	What It Does
lock_sh	1	Creates a shared lock
lock_ex	2	Creates an exclusive lock
lock_nb	4	Creates a nonblocking lock
lock_un	8	Unlocks an existing lock



1   $LOCK_EX = 2;
2   $LOCK_UN = 8;

3   print "Adding an entry to the datafile.\n";
    print "Enter the name: ";
    chomp($name=<STDIN>);
    print "Enter the address: ";
    chomp($address=<STDIN>);

4   open(DB, ">>datafile") || die "Can't open: $!\n";

5   flock(DB, $LOCK_EX) || die ;        # Lock the file

6   print DB "$name:$address\n";

7   flock(DB, $LOCK_UN) || die;         # Unlock the file



#############The seek and tell Functions 
seek是个好函数。

the seek function allows you to move to some byte (not line) position within the file. The seek function returns 1 if successful, 0 otherwise

可以在随意的位置开始文件操作。position： 0 代表文件开头，2代表结尾，1代表当前位置
offset是从position开始的文件的（偏移）位置。可前可后，前为正，后为负

seek(FILEHANDLE, BYTEOFFSET, FILEPOSITION);

The seek function sets a position in a file, where the first byte is 0. Positions are

0 = Beginning of the file

1 = Current position in the file

2 = End of the file

BYTEOFFSET是偏移量。可正可负。 seek(FH,-13,2)： 从末尾，向回13个字符的位置。

用od命令可以显示文件是怎么存储的，unix里回车换行等用\n 

例子：
open (DB,"<datafile") or die "Cannot open the file: $! \n";

while ( $line=<DB>)
{
    if ($line =~ /Lori/)
    {
        print "---$line---\n";
    }
} 

seek(DB,0,0); #如果这里不用seek， 那么想进行下面的操作，必须先把文件关了，再打开。 用了seek， 可以定位到指定位置，对这个例子，回到文件开头，从第一个字符开始。

while (<DB>)
{
    print if /Tommy/;
} 


----
seek(FH,0,1) or die; 当前位置	

----
1   open(FH, "db") or die "Can't open datebook: $!\n";
2   seek(FH,-13,2) or die;
3   while(<FH>){
4       print;
    }

(Output)
4   Karen Evich
从文件末尾开始，向前数13位，恰好是　Karen Evich
用od -c 命令 可以看处文件的存储。 Od -c db 


------
用　tell　命令，可以返回文件的当前字符位置，供seek函数使用。
The tell function returns the current byte position in the file and is used with the seek function to move to that 
position in the file. If FILEHANDLE is omitted, tell returns the position of the file last read.

tell(FILEHANDLE);
tell;

1   open(FH,"db") || die "Can't open: $!\n";
2   while ($line=<FH>) {      # Loop through the whole file
       chomp($line);
3      if ($line =~ /^Lori/) {
4          $currentpos=tell;  # 这个位置恰好是之前的匹配完成，下一个字符开始的位置。
5          print "The current byte position is $currentpos.\n";
6          print "$line\n\n";
       }
    }
7   seek(FH,$currentpos,0);   # Start at the beginning of the file
# 用新的到的位置做偏移量，从开头开始来过。 
8   @lines=(<FH>);
9   print @lines;

用　od -c db ，可以看出，这个位置恰好是匹配完LORI 的那一行后的下一行。 注意这里只能用tell得到的位置做偏移量。因为seek只有三个选项做位置：0，1，2
分别代表开头，当前位置和结尾。




######### Open for Reading and Writing 
　打开文件来读写
Reading and Writing Operations
Symbol		Open For
+<		Read first, then write
 	 "+<" 是先读后写，如果要在已有的文件中，添加数据但不是在文件末尾即在文件开始或中间添加数据，先用seek（）函数定位到要添加数据的位置，
	 然后开始在文件中写入数据
+>		Write first, then read
  	 "+>" 是先写后读，如果文件存在，先把文件的内容删除，再写入数据，然后再读。操作结果：文件中以前的数据被删除，现在文件中只保留目前写入的数据
+>>		Append first, then read


一个例子：
open(FH, "+>file") || die;
print FH "This line is written to file.\n";
seek(FH,0,0);         # Go to the beginning of the file
 while(<FH>) {
        print;            # Reads from file; the line is in $_
}

 file里的文件都被清空，最后只剩下新写入的这行：This line is written to file.


###########Open for Pipes
open a filter so that the output is piped to a system command. The command is preceded by a pipe symbol (|) and replaces the filename argument in the previous examples. The output will be piped to the command and sent to STDOUT.
打开的文件内容作为管道命令后的参数，输出默认是屏幕　STDOUT

open(FILEHANDLE,|COMMAND);


一个例子：
 open(MYPIPE, "| wc -w");
print MYPIPE "apples pears peaches";
 close(MYPIPE);
 这个句柄不需要有一个文件存在。，写入它的内容，会当作参数，管道给后面的一个系统命令。所以，这个输出的结果是3 

又一个例子：
1   open(FOO, "| tr '[a-z]' '[A-Z]'");
2   print FOO "hello there\n";
3   close FOO;   # If you don't close FOO, the output may be delayed

(Output)
2   HELLO THERE



再来一个好例子，把文件里的内容全部转换大小写：
$ cat emp.names
1 Steve Blenheim
2 Betty Boop
3 Igor Chevsky
4 Norma Cord
5 Jon DeLoach
6 Karen Evich

(The Script)
    #!/usr/bin/perl
1   open(FOO, "| sort  +1| tr '[a-z]' '[A-Z]'"); # Open output filter
2   open(DB, "emp.names");       # Open DB for reading
3   while(<DB>)
   { print FOO ; }
4   close FOO;


#########Sending the Output of a Filter to a File (需要再看看！！@@###）	
想把管道输出定向到文件里，而不是像上面一样屏幕输出。那就把STDOUT重定向到一个句柄吧。

open(STDOUT, ">/dev/tty");



####################Input Filter （ 很好用的！）
把一个命令的输出，存储在句柄里。
open(FILEHANDLE, COMMAND|);

一个栗子
1   open(INPIPE, "date |");    
2   $today = <INPIPE> ";
3   print $today;
4   close(INPIPE);

(Output)
Thu Aug 29 09:21:47 CST 2019



再一个栗子：

open (OPENGREP,"find . -size +2k -mtime +20 -exec ls  {} \\;|");
while($filegrep=<OPENGREP>)
{
    print $filegrep;
}

(OUTPUT)
./7_if_only.pl
./5_what_is_in_a_name.pl
./6_whereisoperator.pl
./6_exercise_1-8.pl





######################10.2. Passing Arguments######################

ARGV是一个句柄	

ARGV[0]:	 the name of the first word after the script name 第一个参数（如果是）
$0      :	 is used to hold the name of the Perl script.     脚本名
$#ARGV  : 	 contains the number of the last subscript in the array.最后一个参数 
$#ARGV + 1  	 The number of arguments.参数个数

$ARGV :		contains the name of the currently selected filehandle. <ARGV>里的当前值


一个栗子：
die "$0 requires an argument.\n" if $#ARGV < 0 ;

print "@ARGV\n";
print "$ARGV[1]\n";
print "$ARGV[$#ARGV] is the last argument.\n";

（OUTPUT）
MCdeMacBook-Pro:perl mc$ ./10_file.pl a1 a2 a3 a4 a5(运行行）
a1 a2 a3 a4 a5
a2
a5 is the last argument.



#######
while( <ARGV> ) {print ;} 可以移动每个参数打印出来


####### 又一个栗子
$. 存贮现在的行数。

print "-----------\n";
if ( $#ARGV < 1 )
{
    die " $0: pattern filename(s).\n";
}

$pattern=shift;

while ($line=<ARGV>)
{
    print "$ARGV: $. : $line " if $line =~ /$pattern/i;
    close(ARGV) if eof;
}

=OUTPUT
data: 6 : Karen Evich 601
 db: 7 : Karen Evich



#############################10.3File testing


Operator	Meaning
-r $file	True if $file is a readable file.
-w $file	True if $file is a writeable file.
-x $file	True if $file is an executable file.
-o $file	True if $file is owned by effective uid.
-e $file	True if file exists.
-z $file	True if file is zero in size.
-s $file	True if $file has nonzero size. Returns the size of the file in bytes.
-f $file	True if $file is a plain file.
-d $file	True if $file is a directory file.
-l $file	True if $file is a symbolic link.
-p $file	True if $file is a named pipe or FIFO.
-S $file	True if $file is a socket.
-b $file	True if $file is a block special file.
-c $file	True if $file is a character special file.
-u $file	True if $file has a setuid bit set.
-g $file	True if $file has a setgid bit set.
-k $file	True if $file has a sticky bit set.
-t $file	True if filehandle is opened to a tty.
-T $file	True if $file is a text file.
-B $file	True if file is a binary file.
-M $file	Age of the file in days since modified.
-A $file	Age of the file in days since last accessed.
-C $file	Age of the file in days since the inode changed.


###############练习题B的第三题非常好：找出12小时内修改了的文件，
用stat 函数。利用现在时间和修改时间减，得出修改的间隔。都是是从1970年起的秒数。
和12小时的秒数相比，查找修改时间符合要求的：
     my $lmtimedate = (stat $myfile)[9];
     my $now = time();
     my $howLongAgo = $now - $lmtimedate; #Since epoch time is just a number of seconds, it's easy to calculate short distances in time. 60*60 = 1 hour * 12 = 12 hours.
    
    if ($howLongAgo <= (60*60*12))
    {
        print "$myfile was edited less than 12 hours ago.\n";
    }

PS#### stat 的值
my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
        $atime,$mtime,$ctime,$blksize,$blocks)
           = stat($filename);
OR：
use File::stat;
my $mtime = stat($filename)->mtime;





####################################################################
##################   Chapter 11 Subroutines.   #####################
####################################################################

#######local 和my 

 Any variable declared with local is said to be dynamically scoped, which means it is visible from within the block
 where it was created and visible to any functions called from within this block or any blocks (or subroutines) 
nested within the block where it is defined. If a local variable has the same name as a global variable, 
the value of the global one is saved and a new local variable is temporarily created. When the local variable 
goes out of scope, the global variable becomes visible again with its original value(s) restored. 
After the last statement in a subroutine is executed, its local variables are discarded. 
local 在申明的函数内，以及调用这个函数的自函数内均有效。
My  只在申明的函数内有效，调用的函数内无效。

一个栗子：
1   $friend="Louise";        # Global variables
2   $pal="Danny";
3   print "$friend and $pal are global.\n";
4   sub guests {
5       my $friend="Pat"; # Lexically scoped variable
6       local $pal="Chris";  # Dynamically scoped variable
7       print "$friend and $pal are welcome guests.\n";
8       &who_is_it;          # Call subroutine
    }

9   sub who_is_it {
10      print "You still have your global friend, $friend, here.\n";
11      print "But your pal is now $pal.\n";  # Dynamically scoped
    }

12  &guests;                 # Call subroutine
13  print "Global friends are back: $friend and $pal.\n";


##### 11.2.1: Prototypes
A prototype, also described as a template, tells the compiler how many and what types of arguments 
the subroutine should get when it is called.o call subroutines that have been declared with a prototype, 
the ampersand (&) must be omitted,
Prototypes 告诉编译器，函数要带几个参数，都是什么类型。不过，调用函数的时候，调用符号得省略，否则prototype不起作用。
换句话说，他可以在调用函数时，检查函数的参数定义。
一个栗子：
1   my $a=5;
    my $b=6;
    my $c=7;
2   @list=(100,200,300);
3   sub myadd($$) {       # myadd requires two scalar arguments
        my($x, $y)=@_;
        print $x + $y,"\n";
    }
4   myadd($a, $b);        # Okay
5   myadd(5, 4);          # Okay
6   myadd($a, $b, $c);    # Too many arguments



###### 11.2.2return value
$average    =  &ave(3, 5, 6, 20);
returned value    call to subroutine

The value returned is really the value of the last expression evaluated within the subroutine.
The return function can also be used to return a specified value or to 
return early from the subroutine based on some condition.

可以是最有一个表达式的值，或者是设定的返回值

一个栗子：
    sub MAX {
1       my($max) = shift(@_);
2       foreach $foo ( @_ ){
3           $max = $foo if $max < $foo;
            print $max,"\n";
        }
        print "------------------------------\n";
4       $max;
    }
    sub MIN {
        my($min) = pop( @_ );
        foreach $foo ( @_ ) {
            $min = $foo if $min > $foo;
            print $min,"\n";
        }
        print "------------------------------\n";
        return $min;
    }

5   my $biggest = &MAX ( 2, 3, 4, 10, 100, 1 );
6   my $smallest= &MIN ( 200, 2, 12, 40, 2, 20 );
7   print "The biggest is $biggest and the smallest is $smallest.\n";

所以，返回方式可以为如下两种：
 $max;
 return $min;


##### Context  上下文 	#####
perl对上下文是敏感的。 列表上下文与标量上下文。
scalar and list. When mixing data types, results differ when an expression is evaluated in one or the other context.
比如：
@list = qw( apples pears peaches plums );  # List context 这里会获得一个数组。
$number = @list;   #Scalar context。   这里得到的会是数组数量。 标量上下文



##########wantarray.   ########
The wantarray Function and User-Defined Subroutines

to determine whether the subroutine should be returning a list or a scalar. If your subroutine is called in list context (i.e., the return value will be assigned to an array), then wantarray will return true; otherwise, it will return false.

Wantarray 数组可以决定返回的上下文是标量还是数组，根据上下文需要的类型来判断

一个栗子：

print "What's your full name?\n";
chomp($fullname=(<STDIN>));
@arrayname=title($fullname);
print "Full name is : $arrayname[0],$arrayname[1].\n";

print "Your favourate book is?\n";
chomp($mybook=(<STDIN>));
$goodbook=title($mybook);
print "My Favourite book is: $goodbook\n";

sub title{
    my $text= shift;
    my $newstring;
    $text=lc($text);
    my @newtext=split(" ",$text);
    foreach my $word(@newtext)
    {
        $word=ucfirst($word);
        $newstring .= "$word ";
    }
    my @newarray=split(" ",$newstring);
    chop($newstring);
    return wantarray ? @newarray : $newstring;
}

[output]:
What's your full name?
Peter Parker
Full name is : Peter,Parker.
Your favourate book is?
Harry potter and half blood prince
My Favourite book is: Harry Potter And Half Blood Prince




!!!!!!11.3 和 exercise3 都没看！！！





############################################################
Chapter 12. Modularize It, Package It, and Send It to the Library!
############################################################


#########12.2The Standard Perl Library
The Perl 5 modules end with a .pm extension. In Perl 5, the .pm files are called modules.
 The .pm files are modules written in two programming styles: procedural and 
object oriented. The module filenames start with a capital letter. The .pm filenames 
starting with a lowercase letter are a special type of module, called a pragma. 
A pragma is a module that tells the compiler that certain conditions must be checked 
in a Perl program before it can run. Files that have no extension at all are 
subdirectories. They contain common modules that are divided into several .pm files; 
for example, the Math subdirectory contains BigFloat.pm, BigInt.pm, Complex.pm, 
and Trig.pm.

模块后缀.pm.  有面向过程与面向对象两类模块。　模块文件名以大写字母开头。那些.pm 文件名以小写开头的，
是特殊的模块，成为编译指示，负责告诉编译器在运行一个perl程序前，需要具备的先决条件。没有扩展名的文件是
目录，他们一般里面都包含好几个.pm模块。

######The @INC Array
The special array @INC contains the directory path to where the library routines are located.
@INC中存着库位置的路径。

Perl　-V

###### require
The require function checks to see if the library has already been included.
require (Expr)
require Expr
require


######Using Perl to Include Your Own Library
When including user-defined routines or adding routines to a library, make sure to include 1; 
(a nonzero value) as the last line of the routine. 

Perl　-V 获得　@INC的信息：

路径in my  Mac:libpth=/usr/lib /usr/local/lib
$ perl -e 'print "@INC\n"' 
/Library/Perl/5.18/darwin-thread-multi-2level 
/Library/Perl/5.18 
/Network/Library/Perl/5.18/darwin-thread-multi-2level
 /Network/Library/Perl/5.18 
/Library/Perl/Updates/5.18.2 
/System/Library/Perl/5.18/darwin-thread-multi-2level 
/System/Library/Perl/5.18 
/System/Library/Perl/Extras/5.18/darwin-thread-multi-2level 
/System/Library/Perl/Extras/5.18 .


So:路径是：
/System/Library/Perl/5.18
....


##### Using Perl to Include Your Own Library 
#### 装载自己的模块库。
一个好例子：
1: 先创建一个自己的模块库：
/Users/mc/codes/perl/mylib
2:在这个模块库下，创建一个模块：average.pl：
cat average.pl

#!/usr/bin/perl
package average; # Declare a package
     # Average a list of grades
   sub ave {
       my(@grades)=@_;
        my($num_of_grades)=$#grades + 1;
        foreach $grade ( @grades ){
             $total += $grade;
        }
       $total/$num_of_grades;   # What gets returned
    }
1; # Make sure the file returns true or require will not succeed!

3:在你的工作目录下，在你的程序中将这个模块库倒入。
我的工作目录是：/Users/mc/codes/perl 
/Users/mc/codes/perl/12_modules.pl：
#!/usr/bin/perl
unshift(@INC, "/Users/mc/codes/perl/mylib");
require "average.pl";
print "Enter your midterm scores.\n";
@scores=split(' ', <STDIN>);
printf "The average is %.1f.\n", average::ave(@scores);
# The ave subroutine is found in a file called average.pl


#########12.2.3. Modules and .pm Files
When using one of the modules (those files ending in .pm) provided in the standard Perl library, you must first make sure the @INC array contains the full pathname to your library distribution and that you include the use function with the module name.
要保证@INC数组含有指向发布包库的全路径，并使用 use 函数引用所需模块名。
 perldoc 可以获得库的信息。
perldoc CGI


##########The use Function (Modules and Pragmas) use函数（模块与编译指示）

The use function allows Perl modules and pragmas to be imported into your program at compile time. 
The use function will not import a module if the module's filename does not have the .pm extension.
 The require function does the same thing but does not do imports and loads the module at runtime.
　use可以在编译时，将模块导入程序中。后缀必须时.pm。　require实现的差不多，不过，不是在运行的时间。
To use a module found in a subdirectory, the directory name is followed by two colons and 
the name of the module, such as Math::Bigfloat.pm
那些在子目录下的模块，要用双冒号调用：Math::Bigfloat.pm


A pragma, spelled in lowercase letters, is a directive to the compiler that your program 
should behave in a certain way and, if it doesn't, the program will abort. Some common pragmas 
are lib, strict, subs, and diagnostics.
编译指示时小写开头的。规范程序应该遵守的一些规则。比如：lib, strict, subs, and diagnostics等都是编译指示。
Format
use Module;
use Module ( list );
use Directory::Module;
use pragma (list);
no pragma;


############12.2.4. Exporting and Importing 导入导出





############################################################
Chapter 13. Does This Job Require a Reference?
############################################################



################13.1. What Is a Reference? What Is a Pointer?

A reference is a variable that refers to another one. In short, it contains the address of 
another variable.

A hard reference is a scalar variable that holds the address of another type of data.
硬引用(hard reference)是一种标量型变量，其中含有其他类型数据的地址。

A symbolic reference names another variable rather than just pointing to a value.
Typeglobs, variable names preceded by *, are a kind of symbolic reference. They are aliases.
一个符号引用(symbolic reference)能为另一个变量命名，而不是指向其变量值 。typeglobs 就是一种符号引用，
其变量名前缀是一个 * 字符。它们不过是变量的一种别名而已。

Given:	*town = *city
Then:	$town refers to the scalar $city
@town refers to the array @city

$town{"mayor"} refers to an element of a hash $city{"mayor"}

############The strict Pragma
To protect yourself from inadvertently using symbolic references in a program,
 use the strict pragma with the refs argument. This causes Perl to check that symbolic
 references are not used in the program
使用　strict，参数 refs 可以防止误用符号链接。

The strict pragma ensures that the program uses only hard references and, if it doesn't,
 will abort during compilation and print an error message as shown in the output of this script.
strict 编译指示保证程序只使用硬引用，否则就在编译时退出程序，并打印如此脚本输出内 容所示的出错信息。


   #!/bin/perl
    # Program using symbolic references
1   use strict "refs";  #### 这一行，只有注释掉，才能执行下去。
2   $animal="dog";
3   $dog="Lady";
4   print "Your dog is called ${$animal}\n";
5   eval "\$$animal='Lassie';";
6   print "Why don't you call her ${$animal}?\n";

(Output)
Can't use string ("dog") as a SCALAR ref while "strict refs" in use at
symbolic.plx line 4.


#########The Backslash Operator 反斜杠用于创建硬链接
The backslash unary operator is used to create a hard reference
In the following example, $p is the reference. It is assigned the address of the scalar $x.

$p=\$x;

#######Dereferencing the Pointer. 按地址访问指针

If you print the value of a reference (or pointer), you will see an address.
If you want to go to that address and get the value stored there，that is, dereference the pointer，
the pointer must be prefaced by two "funny" symbols:
1: the dollar sign, because the pointer itself is a scalar
2: the symbol representing the type of data to which it points. 
如果打印出引用的内容，会得到一个地址。如果想得到这个地址里存的数据，需要两个符号前缀。
1:$ 符号，因为引用（或叫指针）本身也是一个普通标量，需要$符号得到其值。
2: 获得实际指向的数据需要的符号，可能是$，可能是->就看其存的数据是什么类型了。

一个栗子：
$num=5;
$p = \$num;

print 'The address asigned $p is ', $p,"\n";
print " The Value stored at this address is $$p \n";
-------output:
The address asigned $p is SCALAR(0x7ff1c700be70)
 The Value stored at this address is 5 

又一个栗子，这次数据不只是标量了：
print "--------13.4 Dereferencing--------\n\n";

@toys=qw(Barbie Elmo ZThomas Barney );

$num=@toys;
%games=("Nintendo" => "Wii",
         "SOny"     => "PlayStation 3",
         "microsoft" => "Xbox 360",
);
$ref1=\$num;
$ref2=\@toys;
$ref3=\%games;

print "There are $$ref1 toys.\n";
print "THey are : ",join(",",@$ref2),"\n";
print "Jessica's favourite toy is $ref2->[0].\n";

while (($key,$value)=each(%$ref3))
{
    print "$key => $value\n";
}

print "They waited in line for a $ref3->{'Nintendo'}\n";

--　output:
--------13.4 Dereferencing--------
There are 4 toys.
THey are : Barbie,Elmo,ZThomas,Barney
Jessica's favourite toy is Barbie.
SOny => PlayStation 3
microsoft => Xbox 360
Nintendo => Wii
They waited in line for a Wii



#############13.1.3. References and Anonymous Variables
It is not necessary to name a variable to create a reference (pointer) to it. If a variable or
 subroutine has no name, it is called anonymous. If an anonymous variable (or subroutine) is
 assigned to a scalar, then the scalar is a reference to that variable (subroutine).

The arrow operator (>), also called the infix operator, is used to dereference the 
reference to anonymous arrays and hashes. Although not really necessary, the arrow operator 
makes the program easier to read.

一个变量想拥有一个引用（或者叫指针），并不一定它本身也必须有一个名字。换言之，它完全可以是匿名的（anonymous).
假如一个匿名的变量被赋予一个标量，那这个标量就作为它的引用了。可以用箭头符号来获得引用指向的变量内容（dereference).
不用也行，不过用了它会更易读。


######Anonymous Arrays 匿名数组
Anonymous array elements are enclosed in square brackets ([]). These square brackets are not to
 be confused with the square brackets used to subscript an array. Here they are used as an 
expression to be assigned to a scalar. The brackets will not be interpolated if enclosed 
within quotes. The arrow (infix) operator is used to get the individual elements of the array.

匿名数组的元素被放在方括号里。换言之，把一些数据放在方括号里，再指给某个标量，就完成了标量作为数据的引用。
这个方括号，可和引用数组元素的方括号不同。方在方括号里，就被当作匿名数组的元素，不会去解释了。用箭头，可以获取数组里的元素
->[]
举起一个栗子：
$arrayref = [ Hello, World, I, love, Figure, Skating ];
print "The value of the reference is \$arrayref \n $arrayref.\n";
print "$arrayref->[1]\n";
print "$$arrayref[1]\n";
print "${$arrayref}[1]\n";
print "@{$arrayref}\n";

-----output:
The value of the reference is $arrayref 
 ARRAY(0x7fa5f400b710).
World
World
World
Hello World I love Figure Skating


###############Anonymous Hashes 匿名哈希
An anonymous hash is created by using curly braces ({}). You can mix array and hash composers 
to produce complex data types. These braces are not the same braces that are used when 
subscripting a hash. The anonymous hash is assigned to a scalar reference.
用波浪括号来创建匿名哈希。也可以把哈希与数组混合起来创建复杂的数据类型。同样赋予标量就构成了标量对匿名哈希的引用。

一个栗子
my $hashref = { "Name"=>"Woody",
                "Type"=>"Cowboy"};
print $hashref->{"Name"}, "\n";
print keys %$hashref, "\n";
print values %$hashref, "\n";
-----output:
Woody
NameType
WoodyCowboy

##########Nested Data Structures
The ability to create references (pointers) to anonymous data structures lends 
itself to more complex types. For example, you can have hashes nested in hashes 
or arrays of hashes or arrays of arrays, etc.	
这种为匿名数据类型建立引用的方式，可以产生复杂的类型。哈希数组的，无穷无尽。

Just as with simpler references, the anonymous data structures are dereferenced 
by prepending the reference with the correct funny symbol that represents its 
data type. For example, if $p is a pointer to a scalar, you can write $$p to 
dereference the scalar, and if $p is a pointer to an array, you can write @$p 
to dereference the array or $$p[0] to get the first element of the array. 

根据不同的数据类型，调用的前置符号可以区别开来使用。比如，$p是个标量的引用，那就可以把$$p写入
一个标量里。$p一个数组的引用，@$p可以写入数组，等等。

##### Lists of lists

A list may contain another list or set of lists, most commonly used to create 
a multidimensional array.
一个列表可以包含另一个列表或列表集，一般用来创建多维数组。

一个栗子：
my $arrays_13=['1','2','3',['red','yellow','blue',]];
# three scalar elements, one refernence element.

# to print the three scalar elements:
for ($i=0;$i<3;$i++)
{
    print $$arrays_13[$i],"\n";
    #print $arrays_13->[$i],"\n"; # The same result
}
#to print the elements of the reference element.
print "\n";
print $$arrays_13[3];
print "\n";
for ($i=0;$i<3;$i++)
{
    print $$arrays_13[3]->[$i];
    print " ---  ";
    print $arrays_13->[3]->[$i],"\n";
 
}
# to print with type funny symbol.
print "\n";
print "@{$arrays_13}\n";
print "@{$arrays_13->[3]}\n";

--　OUTPUT:
1
2
3

ARRAY(0x7fb3350138e8)
red ---  red
yellow ---  yellow
blue ---  blue

1 2 3 ARRAY(0x7fb3350138e8)
red yellow blue


#############13.1.5:reference and subroutines 
### anonymous subroutines
An anonymous subroutine is created by using the keyword sub without a subroutine
 name. The expression is terminated with a semicolon.

一个栗子：
my $subref= sub {print @_ ;};
&$subref('a','b','c');
print "\n";

---OUTPUT:
abc

Note:The scalar $subref is assigned an anonymous subroutine by reference. 
The only function of the subroutine is to print its arguments stored in 
the @_ array.
The subroutine is called via its reference and passed three arguments.


########Subroutines and Passing by Reference
When passing arguments to subroutines, they are sent to the subroutine and
 stored in the @_ array. If you have a number of arguments, say an array, 
a scalar, and another array, the arguments are all flattened out onto the 
@_ array. It would be hard to tell where one argument ended and the other
 began unless you also passed along the size of each of the arrays, and 
then the size would be pushed onto the @_ array and you would have to get
 that to determine where the first array ended, and so on. The @_ could 
also be quite large if you are passing a 1,000-element array. So, the 
easiest and most efficient way to pass arguments is by address
当子程序的参数多，而且类型很杂的时候，传递参数很容易混淆。比如参数里有标量还是数组，传着传着
就会搞不清标量和数组里面各个元素的开始结束位置等。
因此，最简单高效的传参数方式，是采用地址。


一个栗子：
@toys = qw(Buzzlightyear Woody Bo);
$num  = @toys;

sub gifts
{
    my ($n,$t)=@_;
    print "There are $$n gifts\n";
    print "They are: @$t\n";
}
gifts(\$num,\@toys);

---OUTPUT:
There are 3 gifts
They are: Buzzlightyear Woody Bo



另一个栗子：
#########exmaple 13.14reference to pass arrays.

my @list1=(1 .. 100);
my @list2=(5,10,15,20);

sub addemup
{
    my($arr1,$arr2)=@_;
    my ($total);
    print $arr1,"\n";
    print $arr2,"\n";
    
    foreach $num(@$arr1,@$arr2)
    {
        $total+=$num;
    }
    return $total;
}

print "The total is:", &addemup(\@list1,\@list2);

output：
ARRAY(0x7fa5350452a0)
ARRAY(0x7fa535046618)
The total is:5100

 注意！！！ 上面当我写作：foreach $num($arr1,$arr2)，输出是：
ARRAY(0x7fe58f8090a0)
ARRAY(0x7fe58f80b018)
The total is:281247863619768
可见！！！！！ 　@$arr1带入的是数组地址对应的数组，而　$arr存的是地址，而非数组内容！！！切记！！！



###########
13.1.6. Filehandle References
One of the only ways to pass a filehandle to a subroutine is by reference. 
You can use a typeglob to create an alias for the filehandle and then use the backslash
 to create a reference to the typeglob. Wow...
把文件句柄传递函数参数，可能最好的方法就是通过引用了。
可以先给文件句柄建个别名，然后用反斜号建立引用。嘿嘿嘿...

一个栗子：
open (README,"/etc/passwd") || die;

&readit(\*README);

sub readit{
    my ($passwd)=@_;
    print "passwd is $passwd.\n";
    while (<$passwd>)
    {
        #    print; #打印出所有，所以我屏了。
    }
}

SEEK(README,0,0);

OUTPUT:
passwd is GLOB(0x7fd33481d8b8).
Undefined subroutine &main::SEEK called at ./13_reference.pl line 158, <README> line 108.


#############13.1.7 the ref Function
The ref function is used to test for the existence of a reference. If the argument for ref
 is a pointer variable, ref returns the type of data the reference points to; e.g., 
SCALAR is returned if the reference points to a scalar, and ARRAY is returned if it 
points to an array. If the argument is not a reference, the null string is turned.
Ref用来测试一个引用是否存在。如果测试的参数是个指向某种类型的指针引用，会返回具体类型。就是说，返回标量，数组等等

What Is Returned	Meaning
REF	Pointer to pointer
SCALAR	Pointer to scalar
ARRAY	Pointer to array
HASH	Pointer to hash
CODE	Pointer to subroutine
GLOB	Pointer to typeglob


一个栗子：
sub gifts;     # Forward declaration
 $num = 5;
 $junk = "xxx";
 @toys = qw/Budlightyear Woody Thomas/ ;
 gifts( \$num, \@toys, $junk );
 sub gifts {
 my( $n, $t, $j) = @_;
  print "\$n is a reference.\n" if ref($n);
  print "\$t is a reference.\n" if ref($t);
  print "\$j is a not a reference.\n" if ref($j);
  printf "\$n is a reference to a %s.\n", ref($n);
  printf "\$t is a reference to an %s.\n", ref($t);
}

OUTPUT:
$n is a reference.
$t is a reference.
$n is a reference to a SCALAR.
$t is a reference to an ARRAY.



###### 13.2 What you should know

1: what is the difference between a symbolic and a hard reference.
 A hard reference is a scalar variable that holds the address of another 
Type of data.
A symbolic reference names another variable rather than just pointing 
to a value.


2: what is a typeglob?
Typeglobs, names preceded by *,are a kind of symbolic reference. 
They are alias.
 
3: How do you create a pointer to a hash?

By using a curly braces ({}):
my $refhash={"Name"=>"Christine
	       "Type"=>"Idiot"};
4:How can you tell a anonymous array from a named array?

$arrayref=[A, B ,C,D]; : anonymous array $arrayref->[1],$$arrayref[1],${$arrayref}[1]
@array="E ,F ,G ,H";     : named array. 

5:Show two ways to dereference this pointer
$ptr={'Name'=>"John"};

$$ptr{"Name"}: John
$ptr->{"Name"}

测试代码如下：
my $ptr={'Name'=>"John"};
print $$ptr{"Name"},"\n";
print " The second:",$ptr->{"Name"},"\n";


6:How do you dereference this pinter? $p=\$x;

$$p

测试代码如下：
my $x="Christine is a fool.";
$p=\$x;
print "the content of \$x is:",$$p,"\n";


7:what is meant by a nested hash?
Create more complex types.

8:How do you create a two-dimensional array?
my $matrix = [
                [ 0, 2, 4 ],
                [ 4, 1, 32 ],
                [ 12, 15, 17 ]
               ] ;
print "Row 3 column 2 is $matrix->[2]->[1].\n";


9:What is the advantage of passing by reference?

When passing arguments to subroutines, they are sent to the subroutine and stored in 
the @_ array. If you have a number of arguments, say an array, a scalar, and another
 array, the arguments are all flattened out onto the @_ array. It would be hard to 
tell where one argument ended and the other began unless you also passed along the
 size of each of the arrays, and then the size would be pushed onto the @_ array 
and you would have to get that to determine where the first array ended, and so on.
 The @_ could also be quite large if you are passing a 1,000-element array. 
So, the easiest and most efficient way to pass arguments is by address.

10:What is the purpose of the ref function?
The ref function is used to test for the existence of a reference. 



###### 13.3: exercise : It's not polite to point
Rewrite tripper (from Chapter 11) to take two pointers as arguments and copy 
the arguments from the @_ in the subroutine into two my pointer variables.
见13_exercise.pl




################################################################
###chapter 14: Bless Those Things! (Object-Oriented Perl)#######
################################################################

#########14.1 The OOP Paradigm 面向对象示例

Key OOP Words
Word			Perl Meaning
Data encapsulation	（封装）Hiding data and subroutines from the user, as in a package
Inheritance		（继承）The reuse of code, usually from a library where a package inherits from other packages
Polymorphism		（多态）Literally "many forms" and specifically, the ability to extend the functionality of a class
Object			A referenced type that knows what class it belongs to; an instance of a class 一个名词，比如一个人，一只猫，一台电脑，等等。
Method			A special subroutine that manipulates objects 动词，对这个名字的动作或者它会有的动作，比如（人）吃饭，猫（挠人），（电脑）死机等。
Class			A package that contains data and methods
Constructor		构造函数 A method that creates and initializes an object
Destructor		（析构函数）A method that destroys an object
Setters/Getters		set/get方法 Methods that store data in an object or fetch data from an object

Object			An object can be described as a noun 一个名词，比如一个人，一只猫，一台电脑，等等。
Method			Verbs that describe what the object can do or what can be done to it 动词，对这个名字的动作或者它会有的动作，比如（人）吃饭，猫（挠人），（电脑）死机等。
Properties( or attributes)	the adjectives that describe the object 属性或特性。形容词，形容这个名词的。愚蠢的（人），贪婪的（猫），贵（电脑）


####################
14.2. Classes, Objects, and Methods

14.2.3 Class and privacy
Perl does not strictly monitor public/private borders within its modules. To keep variables private, the my function is used
用my确定私有化
The my variables exist only within the innermost enclosing block, subroutine, eval, or file. The my variables cannot be accessed from another package by using the double colon (or single apostrophe), because my variables are not related to any package; they are not stored in the symbol table of the package in which they are created.
my变量只存在于最内层的模块，子函数，eval或者文件中。别处均不能引用。即使自己模块的符号表也别想。

举起一个栗子：
#Example 14.1.
$name="Susan";
my $birthday=1942;

package nosy;
print "Hello $main::name.\n";
print "You were born in $main::birthday?\n";

[output]:
Hello Susan.
You were born in ?


####14.2.4 Objects

To begin with, an object in Perl is created by using a reference. A reference, if you recall, is a scalar that holds the address of some variable. It's a pointer. 
用引用来创建对象（Object）。 一个引用就是一个指向某个变量地址的标量。
所以，它是个指针。
A reference might also point to a variable or subroutine that has no name, called an anonymous variable.
一个引用指针也可以指向匿名变量或自函数，指向数组啦，哈希表啥的是很平常的。

my $ref  = { "Owner"=>"Tom",  "Price"=>"25000" };
To access a value in the anonymous hash, the reference (pointer) $ref can be dereferenced by using the arrow operator as follows:
这个指向匿名哈希的指针，这样来解析：
$ref->{"Owner"}

To make a Perl object, first a reference is created.The reference normally is assigned the address of an anonymous hash. The hash will contain the data members, properties, of the object. In addition to storing the address of the hash, the reference must know what package it belongs to. This is done by creating the reference and then "blessing" it into a package. The bless function acts on the "thing" being referenced in the package, not the reference itself.
通过引用匿名哈希来创建对象。哈希里存着对象属性能信息。
但和传统引用不同的是，普通引用只存个地址就可以了，可对象引用必须得存储对象隶属于那个包，也就是类。这就需要bless.
不过，bless的是只引用指向的内容，也就是对象，可不是引用本身。

my $ref  = { Owner => "Tom",  Price => 250000 };    # This is the object
bless( $ref, Class);   # The object is blessed into the package named Class
return $ref;           # A reference to the object is returned


######## bless 函数
bless REFERENCE, CLASSNAME
bless REFERENCE

To be more technical, the first argument to the bless function must be pointer. The bless function internally tags whatever the pointer is pointing at (called the referent) with a reference to the package where it belongs. This is how an object is created.
bless 函数使用引用寻找所需的对象，并能返回指向该对象的引用。由于 bless 操作将把对象 和特定的包(类)关联起来，因此 Perl 总是能知道各个对象各自属于什么包。

 
一颗栗子：
package House;          # Package declaration

my $ref = { "Owner"=>"Tom", #Anonymous hash; data for the package
    "Price"=>"25000", # Properties/attributes
};

print "The value of \$ref  before blessed is: $ref.\n";
print "The ref function returns （Curious）:",ref($ref), ".\n";
bless($ref, House);

# The bless function creates the object. The hash referenced by
# $ref  is the object. It is blessed into
# the package; i.e., an internal pointer is created to keep track
# of the package where it belongs.

print "The bless function tags the hash with its package name.\n";
print "The value of \$ref is: $ref.\n";
print "The ref function returns the class (package) name:",ref($ref), ".\n";

[output]:
The value of $ref  before blessed is: HASH(0x7ff1058030e8).
The ref function returns （Curious）:HASH.
The bless function tags the hash with its package name.
The value of $ref is: House=HASH(0x7ff1058030e8).
The ref function returns the class (package) name:House.

其中最后一个ref函数的使用。ref函数本是会返回引用所指的类型，比如是哈希还是数组标量等，
但在对象被bless以后，会返回模块（类）的名字。



#####14.2.6 Methods
A method is a subroutine that operates on an object. It is a special subroutine that 
belongs to a class and expects its first argument to be either a package name or a 
reference to an object. This argument is sent by Perl implicitly. Otherwise, it looks 
like any other subroutine. A method is used primarily to create an object, to assign or
 change the data in the object, or to retrieve data from an object

Method (方法）是操作一个对象（object)的子函数(subroutine).它隶属于一个类，并需要包或指向对象的指针作为
第一个参数。当然这第一个参数perl会为你默默搞定。除此之外，它与普通子函数一样。方法主要目的是用来创建对象，分配
或改变对象里的数据，或从对象中提取数据。

## types of methods:方法的类型
There are two types of methods: class (or static) methods and instance (or virtual)
 methods.The class method expects a class name as its first argument, and the 
instance method expects an object reference as its first argument.

有两类方法：类方法或静态方法，实例方法或虚方法。类方法的第一个参数是类名，实例方法的第一个参数需要是对象索引。

class method： In object-oriented programs, a constructor function is a class method 
used to create an object. In Perl, this method is commonly called new, although you
can call it anything you like. The creation of the object is often called the instantiation
of the object, or instance, of the class.

类方法在perl里的析构函数叫做new,用来创建一个对象。

instance methods (also called access methods): You can't use an instance method until 
you have created the object. The method that creates the object is called a constructor.
 It returns a reference to the object. Once the reference to the newly created object 
is returned, the instance method uses that reference, often called $this or $self, 
to get at the object.
实例方法一定要在对象已经建立后才可用。当创建完一个对象后，析构函数回返回一个引用（指针），这个引用
（常叫做$this or $self） 就作为实例方法的第一个参数来获得对象。

### 　Invoking Methods 调用方法
methods are invoked in one of two ways: class method invocation or instance method invocation.
There are two types of syntax for each method call: object-oriented syntax and indirect
 syntax. If you are using objects, either syntax for these method calls is acceptable.
 The older way of calling methods with the double colons is not recommended.
方法调用有两种：类方法调用和实例方法调用
每种方法都有两种调用策略：面向对象语法(object-oriented)与间接语法（indirect)。

####Class Method Invocation 类方法调用
Assume the method name is called new and the return value, $ref, is a pointer to the object.
1) $ref = class->new( list of arguments );   # object-oriented syntax
2) $ref = new class ( list of arguments );   # indirect syntax

If the class is called House, Perl translates
        $ref = House->new();
to
        $ref = House::new(House);

#####Instance Method Invocation 实例方法调用
Assume the method name is called display and the reference to the object is called $ref.

1) $ref->display( list of arguments );    # object-oriented syntax
2) display $ref ( list of arguments );    # indirect syntax

$ref points to an object in a class called House, Perl translates that to
House::display($ref, arguments...);



######### 14.2.7 What an Object-Oriented Module Looks like


主要以书上的Figure14.3为栗子进行解释。
The package will be called a class; so, this is the House class.
The class consists of subroutines, now called methods. The first type of method, 
called new, is a constructor method. It is the method that will define and 
create (construct) the object. When a user of this module calls the method new, 
he will get back a reference to the newly created House object (the address of the house).

 The new method gets the name of the class as it first argument. This method not only
 creates the object but also blesses the object so that the object always knows what 
class (package) it belongs to.

The instance methods must have a reference to the object in order to access the right 
object. The instance methods always get a reference to the object as their first argument.

The second two methods are called access, or instance, methods. 

创建一个名字叫  House.pm的块。这个类就叫House了。注意pm的名字和类的名字是一样的。
类方法： New子函数就是类方法，析构函数，创建这个对象，系统会把第一个参数传入作为对象名。定义一个空匿名哈希，引用指向它。
 bless这个引用与对象，那么引用就是指向这个对象的指针啦。
实例方法： Setdata 和getdata 就是实例方法，一个来设定值，一个来提取值。
我把　Figure14.3调试如下：
House.pm:
package House;
sub new{
    my $class=shift;
    my $ref={};
    bless($ref,$class);
    return $ref;
}

# the new version of new subroutine
sub new{
    my $class=shift;
    my $ref={};
    print "Before blessed,\$ref is $ref.\n ";
    bless($ref,$class);
    print "After blessed,\$ref is $ref.\nAnd the context of \$ref is ", ref($ref),".\n";
    return $ref;
}

sub setdata{
    my $self=shift;
    $self->{"Name"}="Christine";
}

sub getdata{
    my $self=shift;
   print $self->{"Name"},"\n";
}
1;

#### to invoke House.pm
print "\n-------- To invoke House.pm,Figure 14.3---\n";
use House;
$obj1=House->new();
$obj1->setdata();
$obj1->getdata();

[OUTPUT}:
Christine

[OUTPUT with new version of new subroutine]:
Before blessed,$ref is HASH(0x7fa4e800c510).
After blessed,$ref is House=HASH(0x7fa4e800c510).
And the context of $ref is House.
Christine


#######The Class Constructor Method
Constructor is an OOP term for a class method that creates and initializes an object 
into a class. There is no special syntax for a constructor. It is just a method that
 is used to get a reference blessed into a package. 
构造函数是个面向对象名词，是创建和为一个对象初始化入一个类的方法。没特别的语法，
就是个把引用bless进一个包的方法罢了。

The object that is blessed into the new subroutine is usually an anonymous hash 
or anonymous array. The anonymous hash or array is assigned the data that describes
 the object. The data is often described as the properties, or attributes, of the object.
Bless的对象一般都建成匿名哈希或者匿名数组。被赋予描述对象的数据。这些被赋予的数据，就是属性或特性（attributes）


# Example 14.4:

House.pm:
package House;
sub new{
    my $class=shift;
    my $ref={"Owner"=>undef,
        "Price"=>undef,
    };
    bless($ref,$class);
    return $ref;
}
1;

在主程序调用构造函数的两种方法：
use House;
my $Houseref=House->new();
my $Houseref=new House;


##The Class and Instance Methods
Object-oriented programs often use access, or instance, methods to control the way data 
is modified, retrieved, and displayed. In order to manipulate an object, the instance,
 or access, methods require an instance of an object; that is, a reference to an object 
that has already been created.
入口方法，或称实例方法来操作类中数据。首先是得有一个对象吧。就是构造函数创建出的引用指向的对象。
Instance methods take an object reference as their first argument.


Remember, the first argument passed to an instance method is always a reference to 
the object, making Tom Savage the second argument:
注意，　传递进实例方法的第一个参数，总是对象指针（指向对象的引用）
$house->set_owner ("Tom Savage") translates to 
House::set_owner($house, "Tom Savage");

在主程序中：
print "\n-------- Example 14.4---\n";
use House;
my $houseref=House->new();
print "\$Houseref is in main belongs to class ",ref($houseref),"\n";
$houseref->set_owner("Christine Mei");
$houseref->display_owner;

[OUTPUT]:
$Houseref is in main belongs to class House
Christine Mei


#####Passing Parameters to Constructor Methods 给构造函数传递参数。
Instance variables are used to initialize the object when it is created. In this way, 
each time the object is created, it can be customized.
They are called instance variables because they come into existence when the object
 is created, or instantiated. Either an anonymous hash or an anonymous array is 
commonly used to hold the instance variables.

实例变量可以在对象建立时为其初始化。在对象建立时引用所指向的匿名哈希或数组，就成了这些实例变量的载体。

Example 14.6 的模块代码house.pm
#Example 14.6 passing parameters to constructor functions.


sub new{
    my $class=shift;
    my ($owner,$salary)=@_;
    my $ref={"Owner"=>$owner,
        "Price"=>$salary,
    };
    #print "Before blessed,\$ref is $ref.\n ";
    bless($ref,$class);
    print "After blessed,\$ref is $ref.\n";#And the context of \$ref is ", ref($ref),".\n";
    return $ref;
}

sub display_object{
    my $self=shift;
     while (my ($key,$value)= each %$self)
    {
        print "$key: $value \n";
    }
}
1;

相应调用它的主程序：
#### Example 14.6
print "\n-------- Example 14.6---\n";
use House;
my $house1=House->new("Robin",80000);
my $house2=House->new("Christine",2);
$house1->display_object;
$house2->display_object;
print "\$house1:$house1;\$house2:$house2\n";

[OUTPUT]:
After blessed,$ref is House=HASH(0x7f9e4400b5a0).
After blessed,$ref is House=HASH(0x7f9e4400b648).
Price: 80000 
Owner: Robin 
Owner: Christine 
Price: 2 
$house1:House=HASH(0x7f9e4400b5a0);$house2:House=HASH(0x7f9e4400b648)



########Passing Parameters to Instance Methods 给实例方法传递参数
The first argument to an instance method is always a reference to the object. 
The remaining arguments are then processed as they are in any regular subroutine.
传递进实例方法的第一个参数，始终是指向所在对象的引用，或称指针。剩下的参数，传递进来的情形于普通函数一般无二。

14.7的模块代码：
sub new{
    my $class=shift;
    my ($owner,$salary,$style)=@_;
    my $ref={"Owner"=>$owner,
        "Price"=>$salary,
        "Style"=>$style,
    };
    bless($ref,$class);
    return $ref;
}

sub display{
    my $self=shift;
    foreach $key( @_ )
    {
        print "$key: $$self{$key}\n";
        # print "$key:$self->{$key}\n";  two ways to display. 
    }
}
1;

调用它的主程序：
print "\n-------- Example 14.6 Passing parameters to instance methods---\n";

use House;
my $house=House->new("Ken",50000,"Sdney D");
$house->display("Owner","Style");

[OUTPUT]
-------- Example 14.6 Passing parameters to instance methods---
Owner: Ken
Style: Sdney D

注： 上面的 new函数：
The key/value pairs are called the properties, or attributes, of the object. 
The values are passed in as arguments to the constructor. 
The blessing creates an object. The object, referenced by $ref, is blessed into 
the House class so Perl can keep track of the package where the object belongs.

主程序里$house->display("Owner","Style");
The instance method is called with arguments. The first argument is a pointer to 
the object, $house, even though you can't see it. The rest of the arguments, 
provided by the user, are in parentheses.